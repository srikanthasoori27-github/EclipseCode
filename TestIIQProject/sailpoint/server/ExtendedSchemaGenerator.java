/* (c) Copyright 2008 SailPoint Technologies, Inc., All Rights Reserved. */

/**
 * Utility to generate delta schemas to add changes to extended attributes
 * to existing databases.
 *
 * Author: Jeff
 *
 */

package sailpoint.server;

import java.util.ArrayList;
import java.util.List;

import sailpoint.object.ObjectConfig;

import sailpoint.persistence.SailPointSchemaGenerator;
import sailpoint.persistence.ExtendedAttributeUtil;
import sailpoint.persistence.ExtendedAttributeUtil.MappingFile;
import sailpoint.persistence.ExtendedAttributeUtil.PropertyMapping;

import sailpoint.tools.BrandingService;
import sailpoint.tools.BrandingServiceFactory;
import sailpoint.tools.GeneralException;
import sailpoint.tools.Util;

public class ExtendedSchemaGenerator
{

    private static BrandingService brandingService = BrandingServiceFactory.getService();
    private static final String TABLE_PREFIX = brandingService.brandTableName("spt_");

    public static void main(String [] args) {

        try {
            String home = Util.getApplicationHome();

            if (home == null)
                System.err.println("Unable to locate home directory!");
            else {
                println("Home directory: " + home);

                genSchema(home, SailPointSchemaGenerator.TYPE_MYSQL);
                genSchema(home, SailPointSchemaGenerator.TYPE_ORACLE);
                genSchema(home, SailPointSchemaGenerator.TYPE_SQLSERVER);
                genSchema(home, SailPointSchemaGenerator.TYPE_DB2);
            }
        }
        catch (Throwable t) {
            System.err.println(t);
            Throwable cause = t.getCause();
            while ( cause != null ) {
                System.err.println(cause);
                cause = cause.getCause();
            }
            System.exit(1);
        }
    }

    public static void println(Object o) {
        System.out.println(o);
    }
    
    public static final String[] DB2_CRAP = {
        "DB2 requires that integrity be turned off on the modified tables",
        "in order ot add a generated column.  This cascades to all tables that",
        "have a relationship with the modified table.  Integrity checking",
        "must be turned back on manually for each table in dependency order.",
        "Statements to do that are included in this file, but if",
        "necessary they can be regenerated by running the following script:",
        "",
        "db2 connect to " + brandingService.getDbName(),
        "db2 -tx +w \"with gen(tabname, seq) as( select rtrim(tabschema) || '.' || rtrim(tabname) as tabname, row_number() over (partition by status) as seq from  syscat.tables WHERE status='C' ),r(a, seq1) as (select CAST(tabname as VARCHAR(30000)), seq from  gen where seq=1 union all select r.a || ','|| rtrim(gen.tabname), gen.seq from gen , r where (r.seq1+1)=gen.seq ), r1 as (select a, seq1 from r) select 'SET INTEGRITY FOR ' || a || ' IMMEDIATE CHECKED FORCE GENERATED;' from r1 where seq1=(select max(seq1) from r1)\" > fixIntegrity.sql"
    };

    /**
     * The type argument identifies the type of system and also
     * serves as the file extension for the generated files.
     * The dialect argument must be the full path of an 
     * org.hibernate.dialect class.   
     */
    private static void genSchema(String home, String type) 
        throws Exception {

        println("Generating database scripts for " + type);

        if(verify()) {

            String extschema = generateExtendedSchema(home, type);

            String extfile = SchemaGenerator.assemble(home, brandingService.brandFilename("add_identityiq_extensions"), null, type);

            Util.writeFile(extfile, extschema);
        }
    }

    /**
     * Generate schema files for the extended attributes and their indexes.
     * Technically this should probably go in SailPointSchemaGeneartor but 
     * that's more oriented to post-processing the Hibernate generated 
     * schema files.  What we're doing is fairly simple so keeping it here.
     *
     * The patterns are:
     *
     * MySQL
     *
     * alter table identityiq.spt_link add extended1 varchar(450);
     * create index spt_link_extended1_ci on identityiq.spt_link (extended1);
     *
     * Oracle
     * 
     * alter table identityiq.spt_link add extended1 varchar2(450 char);
     * create index identityiq.spt_link_extended1_ci on identityiq.spt_link (upper(extended1));
     *
     * DB2
     * 
     * alter table identityiq.spt_link add extended1 varchar(450),
     *   extended1_ci generated always as (upper(extended1));
     *
     * create index identityiq.spt_link_extended1_ci on identityiq.spt_link (extended1_ci);
     *
     */
    public static String generateExtendedSchema(String home, String type)
        throws Exception {

        List<String> lines = new ArrayList<String>();

        lines.add("--");
        lines.add("-- This script is generated from the *Extended.hbm.xml");
        lines.add("-- files and contains alter statements and indexes for");
        lines.add("-- extended attributes that can be applied to an");
        lines.add("-- existing database.");
        lines.add("--");

        if (type.equals(SailPointSchemaGenerator.TYPE_MYSQL)) {
            lines.add("");
            lines.add("USE " + brandingService.getSchema() +";");
        }
        else if (type.equals(SailPointSchemaGenerator.TYPE_DB2)) {

            lines.add("--");
            for (int i = 0 ; i < DB2_CRAP.length ; i++)
                lines.add("-- " + DB2_CRAP[i]);
            lines.add("--");
            lines.add("");

            lines.add("CONNECT TO " + brandingService.getDbName() + ";");
        }
        else if (type.equals(SailPointSchemaGenerator.TYPE_SQLSERVER)) {
            lines.add("");
            lines.add("USE " + brandingService.getSchema());
            lines.add("GO");
        }

        lines.add("");

        for (int i = 0 ; i < ExtendedAttributeUtil.ExtensibleClasses.length ; i++) {
            generateSchemas(home, type, ExtendedAttributeUtil.ExtensibleClasses[i], lines);
        }

        StringBuilder b = new StringBuilder();
        if (lines != null) {
            for (int i = 0 ; i < lines.size() ; i++) {
                b.append(lines.get(i));
                b.append("\n");
            }
        }

        return b.toString();
    }

    public static boolean verify() throws Exception {
        if(ExtendedAttributeUtil.verifyExtendedHbmFiles()) {
            return true;
        } else {
            throw new GeneralException("Error verifying schemas.");
        }
    }

    /**
     * Generate the schemas for one extensible class.
     */
    public static void generateSchemas(String home, String type, String className, 
                                       List<String> lines)
        throws Exception {

        lines.add("--");
        lines.add("-- " + className);
        lines.add("--");
        lines.add("");

        String table = null;
        if (ObjectConfig.MANAGED_ATTRIBUTE.equals(className))
            table = "managed_attribute";
        else if (ObjectConfig.CERTIFICATION_ITEM.equals(className))
            table = "certification_item";
        else
            table = className.toLowerCase();

        // remove db2 integrity constraints
        if (type.equals(SailPointSchemaGenerator.TYPE_DB2)) {
            lines.add("set integrity for " + brandingService.getSchema() + "." + TABLE_PREFIX + table + " off;");
        }

        MappingFile mappings = ExtendedAttributeUtil.getMappingFile(className);
        if (mappings != null) {
            List<PropertyMapping> props = mappings.getProperties();
            if (props != null) {
                StringBuffer b = new StringBuffer();
                for (PropertyMapping prop : props) {
                    // ignore extended identity for now
                    if (prop.identity) {
                        continue;
                    }

                    b.setLength(0);
                    b.append("alter table " + brandingService.getSchema() + "." + TABLE_PREFIX);
                    b.append(table);
                    b.append(" add " );
                    b.append(getColumnName(prop.name));
                    b.append(" ");
                    if (type.equals(SailPointSchemaGenerator.TYPE_MYSQL) || 
                        type.equals(SailPointSchemaGenerator.TYPE_DB2))
                        b.append("varchar("+prop.length+")");
                    else if (type.equals(SailPointSchemaGenerator.TYPE_ORACLE))
                        b.append("varchar2("+prop.length+" char)");
                    else
                        b.append("nvarchar("+prop.length+") null");
                    b.append(";");
                    lines.add(b.toString());

                    // I wanted to do this in the previous statement,
                    // but Glenn says that's a problem
                    if (type.equals(SailPointSchemaGenerator.TYPE_DB2)) {
                        b.setLength(0);
                        b.append("alter table " + brandingService.getSchema() + "." + TABLE_PREFIX);
                        b.append(table);
                        b.append(" add " );
                        b.append(getColumnName(prop.name));
                        b.append("_ci generated always as (upper(");
                        b.append(getColumnName(prop.name));
                        b.append("));");
                        lines.add(b.toString());
                    }

                    if (prop.index != null && 
                        !type.equals(SailPointSchemaGenerator.TYPE_DB2)) {
                        generateIndex(type, table, prop, lines);
                    }

                    if (type.equals(SailPointSchemaGenerator.TYPE_SQLSERVER))
                        lines.add("GO");
                }

                if (type.equals(SailPointSchemaGenerator.TYPE_DB2)) {

                    // vomit out the previously generated integrity restore
                    lines.add("");
                    String db2Crap = "WEB-INF/database/fragments/restore_" + table + "_integrity.db2";
                    db2Crap = brandingService.brandFilename(db2Crap);
                    lines.add(Util.readFile(db2Crap));

                    lines.add("");

                    // db2 indexes have to go after the vomit
                    for (PropertyMapping prop : props) {
                        if (!prop.identity && prop.index != null)
                            generateIndex(type, table, prop, lines);
                    }
                }

            }
        }

        lines.add("");
    }

    /**
     * Convert a name from the properties file into a column name
     * following Hibernate conventions.  Camel case is split to
     * _ delimited lower case names.  Use the same internal
     * class that Hibernate uses to make sure we follow the same rules.
     */
    static public String getColumnName(String propName) {

        return org.hibernate.cfg.ImprovedNamingStrategy.INSTANCE.columnName(propName);
    }

    /**
     * Max size of a MySQL index. This should be 767 bytes / bytePerCharacter. With UTF-8 this will default to 255
     */
    static private int MYSQL_INDEX_MAX_SIZE = 255;

    /**
     * Add an index definition. 
     */
    static private void generateIndex(String type, String table, PropertyMapping prop, 
                               List<String> lines) {

        if (prop.index != null) {
            StringBuffer b = new StringBuffer();
            b.append("create index " );
            if (type.equals(SailPointSchemaGenerator.TYPE_ORACLE) ||
                type.equals(SailPointSchemaGenerator.TYPE_DB2))
                b.append(brandingService.getSchema() + ".");
            b.append(prop.index);
            b.append(" on " + brandingService.getSchema() + "." + TABLE_PREFIX);
            b.append(table);
            b.append(" (");
            if (type.equals(SailPointSchemaGenerator.TYPE_ORACLE))
                b.append("upper(");
            b.append(getColumnName(prop.name));
            if (type.equals(SailPointSchemaGenerator.TYPE_DB2))
                b.append("_ci");
            if (type.equals(SailPointSchemaGenerator.TYPE_ORACLE))
                b.append(")");
            if (type.equals(SailPointSchemaGenerator.TYPE_MYSQL) && Util.otoi(prop.length) > MYSQL_INDEX_MAX_SIZE) {
                println("Truncating index[" + prop.index + "] to " + MYSQL_INDEX_MAX_SIZE + " chars for MYSQL.");
                b.append("(");
                b.append(String.valueOf(MYSQL_INDEX_MAX_SIZE));
                b.append(")");
            }
            b.append(");");

            lines.add(b.toString());
        }
    }



}

