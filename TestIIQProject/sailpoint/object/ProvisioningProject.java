/* (c) Copyright 2008-2009 SailPoint Technologies, Inc., All Rights Reserved. */
/**
 * An object maintainin the state of a complex provisioning process.
 * The project may include one or more plans partitioned for each
 * IntegrationConfig, data gathered interactively for to satisify templates, 
 * and various options.
 * 
 * These are built and updated by the PlanCompiler, and eventually
 * processed by the PlanEvaluator.  They may be stored in workflows
 * if approvals are necessary before the plans can be evaluated.
 *
 * Author: Jeff
 *
 * Options like noRoleExpansion and allowEntitlementDeprovisioning are
 * maintained in the project since they effect how the plan is compiled
 * and evaluated.  Since plan processing can occur between rounds
 * of user interaction we need to be able to persist everything related
 * to plan compilation.
 *
 */

package sailpoint.object;

import java.util.ArrayList;
import java.util.Collection;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.ListIterator;
import java.util.Map;

import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;

import sailpoint.object.ProvisioningPlan.AbstractRequest;
import sailpoint.object.ProvisioningPlan.AccountRequest;
import sailpoint.object.ProvisioningPlan.AttributeRequest;
import sailpoint.object.ProvisioningPlan.GenericRequest;
import sailpoint.object.ProvisioningPlan.ObjectOperation;
import sailpoint.object.ProvisioningPlan.ObjectRequest;
import sailpoint.object.ProvisioningPlan.Operation;
import sailpoint.object.ProvisioningPlan.PermissionRequest;
import sailpoint.provisioning.PlanCompiler;
import sailpoint.provisioning.PlanUtil;
import sailpoint.tools.GeneralException;
import sailpoint.tools.Message;
import sailpoint.tools.Util;
import sailpoint.tools.xml.AbstractXmlObject;
import sailpoint.tools.xml.SerializationMode;
import sailpoint.tools.xml.XMLClass;
import sailpoint.tools.xml.XMLProperty;
import sailpoint.web.messages.MessageKeys;

/**
 * An object maintaining the state of a complex provisioning process.
 * The project may include one or more plans partitioned for each
 * IntegrationConfig, data gathered interactively for to satisfy templates, 
 * and various options.
 *
 * These are built and updated by the PlanCompiler, and eventually
 * processed by the PlanEvaluator. They can be stored in workflows
 * if approvals are necessary before the plans can be evaluated.
 *
 */
@XMLClass
public class ProvisioningProject extends AbstractXmlObject {

    private static final Log log = LogFactory.getLog(ProvisioningProject.class);

    /**
     * Attribute key used to store the reason a value was filtered.
     */
    public static final String ATT_FILTER_REASON = "reason";

    /**
     * Attribute key used to indicate that a filtered value was logged
     * in a provisioning transaction.
     */
    public static final String ATT_FILTER_LOGGED = "logged";

    /**
     * Enumeration of reasons a value can be filtered out of
     * a plan during compilation.
     */
    @XMLClass
    public enum FilterReason {
        Dependency(MessageKeys.UI_FILTER_REASON_DEPENDENCY),
        Exists(MessageKeys.UI_FILTER_REASON_EXISTS),
        DoesNotExist(MessageKeys.UI_FILTER_REASON_DOES_NOT_EXIST),
        Requested(MessageKeys.UI_FILTER_REASON_REQUESTED);

        private String messageKey;

        FilterReason(String messageKey) {
            this.messageKey = messageKey;
        }

        public String getMessageKey() {
            return messageKey;
        }

    }

    //////////////////////////////////////////////////////////////////////
    //
    // Fields
    //  
    //////////////////////////////////////////////////////////////////////
    
    /**
     * Provisioning options recognized by Provisioner, PlanCompiler, 
     * or PlanEvaluator. When the project is first constructed, these
     * normally come from the task arguments of the task that is using
     * the Provisioner. If the compiled projects results in Questions
     * that need to be sent into a workflow, the options are persisted in
     * the project so the Provisioner can be recreated with them later
     * when the project is ready to evaluate.
     */
    Attributes<String,Object> _attributes;

    /**
     * Name of the associated identity.
     */
    String _identity;

    /**
     * New role assignments being applied to the identity.
     * This is set for projects generated by one of Provisioner's
     * special role reconciliation methods.  
     * 
     * This is not required for plan compilation or evaluation, but 
     * the provisioning workflows need to carry this around so they
     * can recompile the project after questions are answered or
     * assignments are rejected.  It is convenient to maintain this
     * here so the project is self contained.
     *
     * @ignore
     * !! This should be deprecated, need to rethink the Provisioner's
     * reconcile() methods.
     *
     * jsl - 6/26/2012 We have removed arm and reconcile() so these may
     * no longer be necessary.
     */
    List<String> _newAssignments;

    /**
     * Old role assignments held by the identity.
     * This is set for projects generated by one of Provisioner's
     * special role reconciliation methods.  
     *
     * @ignore
     * Ideally we wouldn't need this and just look at the Identity
     * but unfortunately the older ARM and the IIQ identity 
     * workflows have already committed the new assignments whereas
     * the newer identity refresh workflows work the other way, the Identity
     * still has the old assignments.  To avoid assumptions about the
     * state of the Identity the project will maintain both the old and
     * new lists.
     * 
     * !! This should be deprecated, need to rethink the Provisioner's
     * reconcile() methods.
     * 
     * jsl - 6/26/2012 We have removed arm and reconcile() so these may
     * no longer be necessary.
     */
    List<String> _oldAssignments;
    
    /**
     * The original master plan.
     * This is compiled into one or more partitioned plans maintained
     * on the _plans list. It is saved in the project so that the
     * plan can be recompiled after Questions have been answered.
     * 
     * @ignore
     * TODO: This makes newAssignments and oldAssignments somewhat
     * redundant.  The original motivation for newAssignments and
     * oldAssignments was to redo a reconcile(), but if we just
     * save the master plan that reconcile() builds we don't
     * really need the two lists.  Think...
     */
    ProvisioningPlan _masterPlan;

    /**
     * Questions that have been previously submitted and answered.
     * This is not necessarily the list of questions that NEED to 
     * be answered, only those that were answered at some point during
     * the project's lifespan.
     *
     * Each time a project is recompiled, all questions are copied
     * from the _questions list here and reset _questions.
     * This is because workflow approvals can make changes to the
     * master provisioning plan and that can result in fewer
     * questions that need to be answered so we rebuild the _questions
     * list from scratch each time. If a question is still necessary
     * it is copied over from here so it is not asked again. Making
     * this list persist for the duration of the project means that
     * if the workflow ends up putting something back into the 
     * plan that was previously removed, old question will still be
     * around and can also be restored.
     */
    List<Question> _questionHistory;

    /**
     * Partitioned plans generated during compilation.
     * 
     * If the targetIntegration property is null this is the "unmanaged"
     * plan that will not be sent to an IntegrationExecutor. The remediation
     * manager uses this to open work items.
     *
     * If the targetIntegration property is "IIQ" this is a plan 
     * targeting the IdentityIQ identity cube.
     *
     * If the targetIntegration property is non-null and not "IIQ" the
     * value is the name of an IntegrationConfig.
     */
    List<ProvisioningPlan> _plans;

    /**
     * List of missing account attributes must be specified before
     * provisioning can proceed.
     */
    List<Question> _questions;

    /**
     * List of account targeting information for each assignment.
     */
    List<ProvisioningTarget> _targets;

    /**
     * List of meta-data about all expanded items in the project.
     */
    List<ExpansionItem> _expansionItems;
    
    /**
     * List of warning and error messages generated during compilation
     * and evaluation.
     */
    List<Message> _messages;

    /**
     * Set of requests that contains values that were filtered out of
     * the matching provisioned requests.
     */
    List<AbstractRequest> _filtered;

    /**
     * The list of RoleAssignment objects that holds the target account
     * information. Used for target account memory.
     * @deprecated 
     * This is deprecated in 6.3 but the property needs to be kept 
     * so plan xml generated by previous releases can be parsed.
     */
    @Deprecated
    List<RoleAssignment> _roleAssignments;

    //
    // Transient fields
    //
    
    /**
     * A map of integration plans keyed by IntegrationConfig name. 
     */
    Map<String,ProvisioningPlan> _planMap;

    /**
     * Lookup index of expansion items keyed by value.
     */
    Map<Object,List<ExpansionItem>> _itemCache;

    //////////////////////////////////////////////////////////////////////
    //
    // Constructor/Properties
    //
    //////////////////////////////////////////////////////////////////////
    
    public ProvisioningProject() {
    }

    public ProvisioningProject(Attributes<String,Object> atts) {
        _attributes = atts;
    }

    @XMLProperty(mode=SerializationMode.UNQUALIFIED)
    public Attributes<String, Object> getAttributes() {
        return _attributes;
    }
    
    public void setAttributes(Attributes<String, Object> a) {
        _attributes = a;
    }

    @XMLProperty
    public String getIdentity() {
        return _identity;
    }

    public void setIdentity(String s) {
        // Trim this since it will end up trimmed when set on an identity anyway
        _identity = (s != null) ? s.trim() : null;
    }
    
    public void setIdentity(Identity i) {
        _identity = (i != null) ? i.getName() : null;
    }

    @XMLProperty
    public ProvisioningPlan getMasterPlan() {
        return _masterPlan;
    }

    public void setMasterPlan(ProvisioningPlan plan) {
        _masterPlan = plan;
    }

    @XMLProperty(mode=SerializationMode.INLINE_LIST_UNQUALIFIED)
    public List<ProvisioningPlan> getPlans() {
        return _plans;
    }

    public void setPlans(List<ProvisioningPlan> plans) {
        _plans = plans;
        _planMap = null;
    }

    public void add(ProvisioningPlan plan) {
        if (plan != null) {
            // TODO: check for duplicates in case PlanCompiler
            // being misbehaved
            if (_plans == null)
                _plans = new ArrayList<ProvisioningPlan>();
            _plans.add(plan);
            if (_planMap != null)
                _planMap.put(plan.getTargetIntegration(), plan);
        }
    }

    @XMLProperty(mode=SerializationMode.LIST)
    public List<Question> getQuestionHistory() {
        return _questionHistory;
    }

    public void setQuestionHistory(List<Question> questions) {
        _questionHistory = questions;
    }

    @XMLProperty(mode=SerializationMode.LIST)
    public List<Question> getQuestions() {
        return _questions;
    }

    public void setQuestions(List<Question> questions) {
        _questions = questions;
    }

    public List<AccountSelection> getAccountSelections() {
        List<AccountSelection> selections = new ArrayList<AccountSelection>();
        if ((null != _targets) && !_targets.isEmpty()) {
            for (ProvisioningTarget target : _targets) {
                Collection<AccountSelection> currentSelections = target.getAccountSelections();
                if (!Util.isEmpty(currentSelections)) {
                    selections.addAll(currentSelections);
                }
            }
        }

        return selections;
    }
    
    @XMLProperty(mode=SerializationMode.INLINE_LIST_UNQUALIFIED)
    public List<ProvisioningTarget> getProvisioningTargets() {
        return _targets;
    }
    
    public void setProvisioningTargets(List<ProvisioningTarget> list) {
        _targets = list;
    }

    @XMLProperty(mode=SerializationMode.LIST)
    public List<ExpansionItem> getExpansionItems() {
        return _expansionItems;
    }
    
    public void setExpansionItems(List<ExpansionItem> items) {
        _expansionItems = items;
    }
    
    @XMLProperty(mode=SerializationMode.LIST)
    public List<Message> getMessages() {
        return _messages;
    }

    public void setMessages(List<Message> msgs) {
        _messages = msgs;
    }

    public void addMessage(Message msg) {
        if (msg != null) {
            if (_messages == null)
                _messages = new ArrayList<Message>();
            _messages.add(msg);
        }
    }

    /**
     * Gets the list of filtered requests containing the items that were
     * filtered during plan compilation.
     *
     * @return The filtered requests
     */
    @XMLProperty(mode=SerializationMode.LIST)
    public List<AbstractRequest> getFiltered() {
        return _filtered;
    }

    /**
     * Sets the filtered requests containing the items that were filtered
     * during plan compilation.
     *
     * @param filtered The filtered requests.
     */
    public void setFiltered(List<AbstractRequest> filtered) {
        _filtered = filtered;
    }

    /**
     * Gets the request containing the filtered items for the specified request.
     *
     * @param request The request.
     * @return The filtered request.
     */
    public AbstractRequest getFiltered(AbstractRequest request) {
        for (AbstractRequest filtered : Util.iterate(_filtered)) {
            if (filtered.isTargetMatch(request)) {
                return filtered;
            }
        }

        return null;
    }

    /**
     * Adds a filtered attribute/permission request value to the project. Uses the
     * value in the request as the filtered value.
     *
     * @param parent The parent account/object request.
     * @param request The attribute/permission request.
     */
    public <T extends GenericRequest> void logFilteredValue(AbstractRequest parent, T request, FilterReason reason) {
        if (request != null) {
            logFilteredValue(parent, request, request.getValue(), reason);
        }
    }

    /**
     * Adds a filtered attribute/permission request value to the project.
     *
     * @param parent The parent account/object request.
     * @param request The attribute/permission request.
     * @param value The filtered value.
     */
    public <T extends GenericRequest> void logFilteredValue(AbstractRequest parent, T request,
                                                            Object value, FilterReason reason) {
        if (parent != null && request != null && isValidFilterValue(value)) {
            boolean logged;

            AbstractRequest filtered = getOrCreateFiltered(parent);
            if (request instanceof AttributeRequest) {
                logged = isFilteredValueLogged(request, value, filtered.getAttributeRequests());
            } else {
                logged = isFilteredValueLogged(request, value, filtered.getPermissionRequests());
            }

            if (!logged) {
                GenericRequest clone = request.clone();
                clone.setValue(value);
                clone.setArguments(null);
                clone.put(ATT_FILTER_REASON, reason);
                // iiqpb-435 copy over the assignment flag so we can
                // add/remove AttributeAssignments for filtered things
                clone.setAssignment(request.isAssignment());
                // IIQSAW-1982 -- copy over sunset date in case it is updating the sunset date.
                clone.setRemoveDate(request.getRemoveDate());
                filtered.add(clone);
            }
        }
    }

    /**
     * Determines if the value is valid for filter logging. If the value is null
     * or is a collection with zero elements then it does not need to be logged.
     *
     * @param value The value.
     * @return True if valid, false otherwise.
     */
    private boolean isValidFilterValue(Object value) {
        if (value == null) {
            return false;
        }

        // make sure value has items if it is a list
        if (value instanceof List<?>) {
            List<?> valueList = (List<?>) value;
            if (Util.isEmpty(valueList)) {
                return false;
            }
        }

        return true;
    }

    /**
     * Determines if the specified value has already been filtered given the
     * existing list of requests for that request type, either attribute or
     * permission requests.
     *
     * @param request The attribute/permission request.
     * @param value The filtered value.
     * @param existingRequests The existing filtered requests.
     * @return True if the value has been logged previously, false otherwise.
     */
    private <T extends GenericRequest> boolean isFilteredValueLogged(GenericRequest request,
                                                                     Object value,
                                                                     List<T> existingRequests) {
        return PlanUtil.exists(existingRequests, request, value);
    }

    /**
     * Gets or creates a filtered request that matches the specified request.
     *
     * @param request The request.
     * @return The request that holds the filtered items.
     */
    private AbstractRequest getOrCreateFiltered(AbstractRequest request) {
        AbstractRequest filteredRequest = getFiltered(request);
        if (filteredRequest == null) {
            filteredRequest = request.cloneRequest();
            filteredRequest.setAttributeRequests(null);
            filteredRequest.setPermissionRequests(null);

            addFiltered(filteredRequest);
        }

        return filteredRequest;
    }

    /**
     * Adds a parent request which will hold the attribute/permission requests
     * with filtered values.
     *
     * @param request The request.
     */
    private void addFiltered(AbstractRequest request) {
        if (_filtered == null) {
            _filtered = new ArrayList<AbstractRequest>();
        }

        _filtered.add(request);
    }

    /**
     * The RoleAssignment list was maintained prior to 6.3 to pass information
     * about assigned roles to IIQEvaluator. Starting in 6.3 
     * ProvisioningTarget is used for this, but the property needs to be retained 
     * for awhile so plan XML  can be parsed in workflows that were created with
     * earlier releases.
     * @deprecated replaced by {@link ProvisioningTarget} model
     */
    @XMLProperty(mode=SerializationMode.LIST)
    @Deprecated
    @SuppressWarnings("deprecation")
    public List<RoleAssignment> getRoleAssigments() {
        return _roleAssignments;
    }

    /**
     * @deprecated replaced by {@link ProvisioningTarget} model
     */
    @Deprecated
    @SuppressWarnings("deprecation")
    public void setRoleAssigments(List<RoleAssignment> roleAssignments) {
        _roleAssignments = roleAssignments;
    }

    /**
     * @deprecated replaced by {@link ProvisioningTarget} model
     */
    @Deprecated
    @SuppressWarnings("deprecation")
    public void addRoleAssigment(RoleAssignment roleAssignment) {
        if (roleAssignment == null) {
            return;
        }

        if (_roleAssignments == null) {
            _roleAssignments = new ArrayList<RoleAssignment>();
        }

        _roleAssignments.add(roleAssignment);
    }

    //////////////////////////////////////////////////////////////////////
    //
    // Utilities
    //
    //////////////////////////////////////////////////////////////////////
    
    public Identity resolveIdentity(Resolver r) throws GeneralException {

        Identity i = null;
        if (_identity != null)
            i = r.getObjectByName(Identity.class, _identity);
        return i;
    }

    public Object get(String name) {
        
        return (_attributes != null) ? _attributes.get(name) : null;
    }

    public boolean getBoolean(String name) {
        
        return (_attributes != null) ? _attributes.getBoolean(name) : false;
    }

    public String getString(String name) {

        return (_attributes != null) ? _attributes.getString(name) : null;
    }

    /**
     * Set an option, try to keep the map clean.
     */
    public void put(String name, Object value) {
        if (name != null) {
            if (_attributes == null)
                _attributes = new Attributes<String,Object>();

            _attributes.putClean(name, value);
        }
    }

    /**
     * Determine who the "requster" of this project is.
     * Remediation plans have historically set this in the 
     * "List<Identity> _requesters" property of the master plan.
     *
     * Newer plan builders pass the ATT_REQUESTER option
     * in either the master provisioning plan or a compiler option
     * when building the Provisioner.
     *
     * @ignore
     * I like using Strings here so the names can be abstract, and if
     * coming from a web service do not necessarily have to correspond
     * to Identity objects.
     */
    public String getRequester() {

        // who should win?  Since the args are newer use the
        String requester = getString(ProvisioningPlan.ARG_REQUESTER);

        if (requester == null && _masterPlan != null) {
            List<Identity> idents = _masterPlan.getRequesters();
            if (idents != null && idents.size() > 0) {
                Identity req = idents.get(0);
                // some of the remediation tests have a null here!
                if (req != null)
                    requester = req.getName();
            }
        }
        return requester;
    }

    /**
     * Replace one plan with another.
     * This is intended for use only by PlanEvaluator as it replaces
     * the original plans with the annotated plans returned by the
     * executors.
     */
    public boolean replace(ProvisioningPlan orig, ProvisioningPlan neu) {

        boolean replaced = false;
        if (_plans != null) {
            ListIterator<ProvisioningPlan> it = _plans.listIterator();
            while (it.hasNext()) {
                ProvisioningPlan p = it.next();
                if (p == orig) {
                    replaced = true;
                    it.set(neu);
                    break;
                }
            }
        }
        return replaced;
    }

    /**
     * Return true if the project is logically empty.
     * This is an optimization needed by Identitizer which does not want to 
     * launch a refresh workflow if there is nothing tangible in the project.
     */
    public boolean isEmpty() {
        boolean empty = true;
        for (ProvisioningPlan plan : Util.iterate(_plans)) {
            if (!plan.isEmpty()) {
                empty = false;
                break;
            }
        }
        return empty;
    }

    //////////////////////////////////////////////////////////////////////
    //
    // Plan Lookup
    //
    //////////////////////////////////////////////////////////////////////
    
    /**
     * Reset the compiled plans. This is intended for use during recompilation
     * where the master plan is recompiled factoring in any newly
     * answered Questions.
     *
     * The current question list is moved over to the question history list,
     * these will be brought back over if necessary.
     *
     * @ignore
     * Note that we have to retain even unanswered questions in the history
     * because we may not have generated forms for those yet, and we need
     * to be using the owner that was calculated originally.
     */
    public void resetCompilation() throws GeneralException{

        _plans = null;
        _planMap = null;
        _messages = null;
        _roleAssignments = null;
        _filtered = null;

        // move the questions that have been answered over to the history list
        List<Question> oldQuestions = _questions;
        _questions = null;

        if (oldQuestions != null) {
            for (Question q : oldQuestions)
                addQuestionHistory(q);
        }

        // TODO: Decide what to do about the Question list
        // in the ProvisioningTargets!!
    }

    /**
     * Reset any status related to plan evaluation.
     * @ignore
     * Normally there won't be any since we usually recompile the plan
     * immediately before evaluation.
     */
    public void resetEvaluation() {
        if (_plans != null) {
            for (ProvisioningPlan plan : _plans)
                resetEvaluation(plan);
        }
    }

    private void resetEvaluation(ProvisioningPlan plan) {
        if (plan != null) {
            plan.setResult(null);
            List<AccountRequest> accounts = plan.getAccountRequests();
            if (accounts != null) {
                for (AccountRequest account : accounts) {
                    account.setResult(null);
                    List<AttributeRequest> atts = account.getAttributeRequests();
                    if (atts != null) {
                        for (AttributeRequest att : atts)
                            att.setResult(null);
                    }
                    List<PermissionRequest> perms = account.getPermissionRequests();
                    if (perms != null) {
                        for (PermissionRequest perm : perms)
                            perm.setResult(null);
                    }
                }
            }
        }
    }

    public ProvisioningPlan getPlan(String target) {
        if (_planMap == null) {
            _planMap = new HashMap<String,ProvisioningPlan>();
            if (_plans != null) {
                for (ProvisioningPlan plan : _plans) 
                    _planMap.put(plan.getTargetIntegration(), plan);
            }
        }
        return _planMap.get(target);
    }

    /**
     * CONSEALINK-204 - Retrieves the list of existing plans from project using targetIntegration
     * The user defined integrations can add more than one plan to project with 
     * same targetIntegration
     * 
     * @param target
     * @return list plan
     */
    public List<ProvisioningPlan> getPlans(String target) {
        List<ProvisioningPlan> plans = null;
        if (_plans != null) {
            for (ProvisioningPlan plan : Util.iterate(_plans)) {
                String targetIntegration = plan.getTargetIntegration();
                if (Util.nullSafeEq(targetIntegration, target)) {
                    if (plans == null) {
                        plans = new ArrayList<ProvisioningPlan>();
                    }
                    plans.add(plan);
                }
            }
        }
        return plans;
    }

    public ProvisioningPlan internPlan(String target) {
        ProvisioningPlan plan = getPlan(target);
        if (plan == null) {
            plan = new ProvisioningPlan();
            plan.setTargetIntegration(target);
            // Set initial trackingId for this plan
            plan.setTrackingId(Util.uuid());
            add(plan);
        }
        return plan;
    }

    /**
     * Finds an existing provisioning plan from the provisioning
     * project. If not found, then creates it and add to the
     * provisioning project.
     *
     * @ignore
     * The plan compiler invokes this when integration config
     * has 'mutltipleTicket' flag is true and 'groupTicketBy'
     * parameter contains the value 'Application'.
     *
     * The user defined integrations can add more than one plan
     * to the project with same targetIntegration, therein we can't
     * use the planMap to retrieve the provisioning plan. As we know,
     * the planMap is a HashMap which do not support duplicate keys.
     *
     * @param target
     * @param appName
     * @return plan
     */
    public ProvisioningPlan internPlan(String target, String appName) {
        // @ignore
        // Sigh, select an existing plan whose target integration
        // matches the given target, then inside that plan finds
        // AbstractRequest whose app name matches with the given
        // application name. If match found, then return that
        // provisioning plan which wraps the request whose app name
        // matches with the given app name. This avoids creating
        // a new provisioning plan if there is already a provisioning
        // plan containing the abstract request whose app name
        // matches the given app name. This way all account
        // requests having the same app name will be grouped
        // together in a single provisioning plan, therein a single
        // ticket will be created for all requests wrapped under
        // the provisioning plan.
        if (Util.isNotNullOrEmpty(appName)) {
            for (ProvisioningPlan plan : Util.iterate(_plans)) {
                if (Util.nullSafeEq(plan.getTargetIntegration(), target)) {
                    for (AccountRequest accReq : Util.iterate(plan.getAccountRequests())) {
                        if (Util.nullSafeEq(accReq.getApplicationName(), appName)) {
                            return plan;
                        }
                    }
                    for (ObjectRequest objReq : Util.iterate(plan.getObjectRequests())) {
                        if (Util.nullSafeEq(objReq.getApplicationName(), appName)) {
                            return plan;
                        }
                    }
                }
            }
        }

        // Otherwise, create a new plan and add to the project.
        ProvisioningPlan plan = new ProvisioningPlan();
        plan.setTargetIntegration(target);
        add(plan);

        return plan;
    }

    /**
     * Finds an existing provisioning plan from the provisioning
     * project. If not found, then creates new provisioning plan
     * and add to the provisioning project.
     *
     * @ignore
     * The plan compiler invokes this when integration config
     * has 'mutltipleTicket' flag is true and 'groupTicketBy'
     * is not furnished or contains value other than the
     * 'Application'.
     *
     * Having one plan per integration is one of the fundamental
     * assumptions of the plan compiler, but here we are modifying
     * it to produce the multiple plans for individual integration!
     *
     * The user defined integrations can add more than one plan
     * to the project with same targetIntegration, therein we can't
     * use the planMap to retrieve the provisioning plan. As we know,
     * the planMap is a HashMap which do not support duplicate keys.
     *
     * @param target
     * @param req
     * @return plan
     */
    public ProvisioningPlan internPlan(String target, AbstractRequest req) {
        // @ignore
        // CONSEALINK-436
        // Sigh, it check's the exact match of receiving AbstractRequest
        // inside all existing plans. If match found, then return
        // that provisioning plan which wraps the matched request.
        // This avoids making a new provisioning plan if there is
        // already a provisioning plan containing the same abstract
        // request we had here.
        //
        // Kludge: The delete operation check is needed in the
        // certification where account revocations produces
        // multiple duplicate account request (having an operation
        // delete) based on the number of the entitlements for
        // that account. This situation has never come in the
        // LCM delete account operation, since there can't be
        // duplicate account correlated to the single identity.
        //
        // Don't worry about operation transformation! The
        // operation transformation happens later, after this.
        if (req.getOp() == ObjectOperation.Delete) {
            for (ProvisioningPlan plan : Util.iterate(_plans)) {
                if (Util.nullSafeEq(plan.getTargetIntegration(), target)) {
                    if (plan.getMatchingRequest(req) != null) {
                        return plan;
                    }
                }
            }
        }

        // Otherwise, create a new plan and add to the project.
        ProvisioningPlan plan = new ProvisioningPlan();
        plan.setTargetIntegration(target);
        add(plan);

        return plan;
    }

    public ProvisioningPlan getIIQPlan() {
        return getPlan(ProvisioningPlan.APP_IIQ);
    }

    public ProvisioningPlan internIIQPlan() {
        return internPlan(ProvisioningPlan.APP_IIQ);
    }

    /**
     * Return the single AccountRequest for the IdentityIQ Identity
     * from the partitioned plans. There can only be one of these.
     */
    public AccountRequest getIIQAccountRequest() {
        AccountRequest req = null;
        ProvisioningPlan plan = getIIQPlan();
        if (plan != null) {
            List<AccountRequest> requests = plan.getAccountRequests();
            if (requests != null && requests.size() > 0)
                req = requests.get(0);
        }
        return req;
    }

    public ProvisioningPlan getUnmanagedPlan() {
        // Hmm, we had been doing this but it became unreliable in 6.0 testing
        // Not sure why but the _planMap was empty.  The way _playMap is being
        // managed is fragile anyway...
        //return getPlan(null);
        ProvisioningPlan found = null;
        if (_plans != null) {
            for (ProvisioningPlan plan : _plans) {
                if (plan.getTargetIntegration() == null) {
                    found = plan;
                    break;
                }
            }
        }
        return found;
    }

    /**
     * Return true if the project contains an unmanaged plan with
     * interesting things. This is used in a few cases where you need
     * to check for the need to do "manual actions" by opening work items
     * for the unmanaged plan.  
     * 
     * @ignore
     * Be careful not to return true if the plan
     * is non-null but empty so we don't launch a refresh workflow 
     * that ends up doing nothing.
     */
    public boolean hasUnmanagedPlan() {
        ProvisioningPlan plan = getUnmanagedPlan();
        return (plan != null && !plan.isEmpty());
    }

    public ProvisioningPlan internUnmanagedPlan() {
        return internPlan(null);
    }

    public void remove(ProvisioningPlan plan) {
        if (_plans != null)
            _plans.remove(plan);

        if (_planMap != null)
            _planMap.remove(plan.getTargetIntegration());
    }

    public List<ProvisioningPlan> getIntegrationPlans() {
        List<ProvisioningPlan> iplans = null;
        if (_plans != null) {
            for (ProvisioningPlan plan : _plans) {
                String target = plan.getTargetIntegration();
                if (target != null && !target.equals(ProvisioningPlan.APP_IIQ)) {
                    if (iplans == null)
                        iplans = new ArrayList<ProvisioningPlan>();
                    iplans.add(plan);
                }
            }
        }
        return iplans;
    }

    //////////////////////////////////////////////////////////////////////
    //
    // Question Management
    //
    //////////////////////////////////////////////////////////////////////

    /** 
     * Look for a question on one of the lists.  Note that when
     * there is a combo of create and update requests on the same app,
     * we have to make sure the target remains null for the create (see TODO in TemplateCompiler.newQuestion)
     * even if we do end up with a native identity after the policy gets processed.
     */
    private Question getQuestion(List<Question> questions, Question.Type type, String source, String target, String attributeName) {
        Question found = null;
        List<Question> questionsReturned = getQuestionsBySource(questions, type, source);
        for(Question q : questionsReturned) {
            String qTarget = q.getTarget();
            String qAttributeName = q.getAttributeName();
            if(Util.nullSafeEq(qAttributeName, attributeName, true)) {
                if(Util.nullSafeEq(qTarget, target, true)) {
                    found = q;
                    break;
                }
            }
        }
        
        if(found == null && hasOldSchoolQuestions()) {
            String fieldName = source + ":" + attributeName;
            found = getQuestion(questions, fieldName);
        }

        if (found == null) {
            if (Util.isNotNullOrEmpty(target)) {
                for (Question q : questionsReturned) {
                    String qTarget = q.getFutureTarget();
                    String qAttributeName = q.getAttributeName();
                    if (Util.nullSafeEq(qAttributeName, attributeName, true)) {
                        if (Util.nullSafeEq(qTarget, target, false)) {
                            found = q;
                            break;
                        }
                    }
                }
            }
        }
        
        return found;
    }
    
    /**
     * Allow us to find all questions associated with a type and source
     * @param questions
     * @param type
     * @param source
     * @return all questions associated with a type and source
     */
    private List<Question> getQuestionsBySource(List<Question> questions, Question.Type type, String source) {
        List<Question> questionReturn = new ArrayList<Question>();
        
        if (questions != null && type != null) {
            for (Question q : questions) {
                Question.Type qType = q.getType();
                if (Util.nullSafeEq(qType, type, true)) {
                    if(source != null) {
                        String qSource = q.getSource();
                        if(Util.nullSafeEq(qSource, source, true)) {
                            questionReturn.add(q);
                        }
                    } else if (this.get(PlanCompiler.ARG_QUESTION_AUTHORITY) != null){
                        questionReturn.add(q);
                    }
                }
            }
        }
        
        return questionReturn;
    }

    /**
     * Look for an active question.
     */
    public Question getQuestion(Question.Type type, String source, String target, String attributeName) {

        return getQuestion(_questions, type, source, target, attributeName);
    }

    /**
     * Look for a previously answered question.
     */
    public Question getAnsweredQuestion(Question.Type type, String source, String target, String attributeName) {

        return getQuestion(_questionHistory, type, source, target, attributeName);
    }
    
    /**
     * Quick convenience method to know when we have to fall back to deprecated methods.
     * The assumption is that we will not have a mix of old style and new style Questions.
     */
    private boolean hasOldSchoolQuestions() {
        boolean oldSchoolQuestions = false;
        if(_questions != null && _questions.size() > 0) {
            Question q = _questions.get(0);
            if(q.getType() == null && q.getSource() == null && q.getTarget() == null && q.getAttributeName() == null) {
                oldSchoolQuestions = true;
            }
        } else if(_questionHistory != null && _questionHistory.size() > 0) {
            Question q = _questionHistory.get(0);
            if(q.getType() == null && q.getSource() == null && q.getTarget() == null && q.getAttributeName() == null) {
                oldSchoolQuestions = true;
            }
        }
        return oldSchoolQuestions;
    }

    @Deprecated
    private Question getQuestion(List<Question> questions, String name) {
        Question found = null;
        if(questions != null && name != null) {
            for(Question q : questions) {
                Field f = q.getField();
                if(f != null && name.equals(f.getName())) {
                    found = q;
                    break;
                }
            }
        }
        return found;
    }

    public void removeAnsweredQuestion(Question q) {
        if (_questionHistory != null)
            _questionHistory.remove(q);
    }
    
    public void removeQuestion(Question q) {
        if (_questions != null) {
            _questions.remove(q);
        }
    }

    /**
     * Add a question to the history.
     * 
     * @ignore
     * Since we try to reuse the same Question object we shouldn't see
     * duplicates but be safe and warn.
     */
    public void addQuestionHistory(Question q) throws GeneralException{
        if (q != null) {
            Field f = q.getField();
            if (f != null) {
                Question existing = getQuestion(_questionHistory, q.getType(), q.getSource(), q.getTarget(), q.getAttributeName());
                if(existing == null && hasOldSchoolQuestions()) {
                    existing = getQuestion(_questionHistory, f.getName());
                }
                
                if (existing == null) {
                    if (_questionHistory == null)
                        _questionHistory = new ArrayList<Question>();
                    _questionHistory.add(q);
                }   
                else if (existing == q) {
                    if (log.isErrorEnabled())
                        log.error("Question already exists in history: " + existing.toXml());
                }
                else {
                    if (log.isErrorEnabled())
                        log.error("Duplicate question found in history: " + q.toXml());
                    
                    // assume this one is more recent and should replace the old one
                    _questionHistory.remove(existing);
                    _questionHistory.add(q);
                }
            }
        }
    }
    
    /**
     * Get the total question count to allow us to name fields uniquely.
     * @return the total question count
     */
    public int getTotalQuestionCount() {
        int questionCount = 0;
        if(null != _questions) {
            questionCount = _questions.size();
        }
        if(null != _questionHistory) {
            questionCount += _questionHistory.size();
        }
        return questionCount;
    }

    /**
     * Add a new question to the required question list.
     */
    public void addQuestion(Question q) throws GeneralException {
        if (q != null) {
            Field f = q.getField();
            if(f != null) {
                String questionAuthority = (String)this.get(PlanCompiler.ARG_QUESTION_AUTHORITY);
                Question existing = getQuestion(_questions, q.getType(), q.getSource(), q.getTarget(), q.getAttributeName());
                //Don't allow this question to be added since
                //we have an existing question that has priority
                boolean doNotAdd = false;
                //an unshown question that doesn't have priority should be removed
                //if another question has the same field.
                boolean removeHistory = false;
                
                //Question authority, remove non-priority questions if they exist or prevent a new question from getting added
                if (questionAuthority != null && existing == null) {

                    existing = getQuestionMatchingField(q, _questions, questionAuthority);
                    if (existing == null) {
                        existing = getQuestionMatchingField(q, _questionHistory, null);
                        if (existing != null && !existing.isShown()) {
                            removeHistory = true;
                        } else if (existing != null){
                            //Don't allow the new question to be added since it's already been asked.
                            doNotAdd = true;
                            existing = null;
                        }
                    }
                    
                    if (existing != null) {
                        if (log.isInfoEnabled()) {
                            log.info("Question authority is removing a question from the provisioing project.\n" + existing.toXml());
                        }
                    }
                    
                }
                
                if(existing == null && hasOldSchoolQuestions()) {
                    existing = getQuestion(_questions, f.getName());
                }
                
                if (_questions == null) {
                    _questions = new ArrayList<Question>();
                }
                
                if (existing == null) {
                    if (!doNotAdd) {
                        _questions.add(q);
                    }
                } else if (existing == q) {
                    if (log.isErrorEnabled()) {
                        log.error("Question already exists: " + q.toXml());
                    }
                } else {
                    if (log.isErrorEnabled() && questionAuthority == null) {
                        log.error("Duplicate active question: " + q.toXml());
                    }
    
                    // assume this one is more recent and should replace the old one
                    if (removeHistory) {
                        _questionHistory.remove(existing);
                    } else {
                        _questions.remove(existing);
                    }
                    
                    if (!doNotAdd) {
                        _questions.add(q);
                    }
                }
                
                if (log.isInfoEnabled() && doNotAdd) {
                    log.info("Question authority is preventing a question from being added to the project.\n" + q.toXml());
                }
                
                // should have removed this by now
                if (_questionHistory != null && _questionHistory.contains(q))
                    _questionHistory.remove(q);
            }
        }
    }
    
    /**
     * getQuestionMatchingField
     * @param q
     * @param questions
     * @param questionAuthority
     * @return
     * Don't depend on question details, but use field details instead.
     */
    private Question getQuestionMatchingField(Question q, List<Question> questions, String questionAuthority) {
        Question existing = null;
        for (Question potentialExisting : Util.iterate(questions)) {
            if (potentialExisting != null && !Util.nullSafeCaseInsensitiveEq(potentialExisting.getType().toString(), questionAuthority)) {
                if(q.fieldsMatch(potentialExisting)) {
                    existing = potentialExisting;
                    break;
                }
            }
        }
        
        return existing;
    }

    /**
     * Return true if the project has active questions.
     */
    public boolean hasQuestions() {
        
        return (_questions != null && _questions.size() > 0);
    }
    
    //////////////////////////////////////////////////////////////////////
    //
    // AccountSelection Management
    //
    //////////////////////////////////////////////////////////////////////

    /**
     * Return the AccountSelection for the given application if there is one.
     */
    public AccountSelection getAccountSelection(Application app, String sourceRole, String assignmentId) {
        AccountSelection account = null;
        if (null != _targets) {
            for (ProvisioningTarget current: _targets) {
                if (null != assignmentId && assignmentId.equals(current.getAssignmentId())) {
                    AccountSelection selection = current.getAccountSelection(app, sourceRole);
                    if (selection != null) {
                        account = selection;
                        break;
                    }
                } else if (assignmentId == null){
                    AccountSelection selection = current.getAccountSelection(app, sourceRole);
                    if (selection != null) {
                        account = selection;
                        break;
                    }
                }
            }
        }
        return account;
    }
    
    /**
     * Add an AccountSelection to this project with the given ambiguous set of
     * links. These links should all be on the same application.  Note that a target
     * is being added for each assignment on the given request.
     */
    public void addAccountSelection(AccountRequest request, List<Link> links) {
        if ((null != links) && !links.isEmpty()) {
            List<String> assignmentIds = request.getAssignmentIdList();
            if (null == _targets) {
                _targets = new ArrayList<ProvisioningTarget>();
            }
            String sourceRole = request.getSourceRole();
            if (!Util.isEmpty(assignmentIds)) {
                for (String assignmentId : assignmentIds) {
                    ProvisioningTarget target = getProvisioningTarget(assignmentId);
                    if (target == null) {
                        target = new ProvisioningTarget();
                        target.setAssignmentId(assignmentId);
                        target.setRole(sourceRole);
                        _targets.add(target);
                    }
                    target.addAccountSelection(links, sourceRole);
                }
            } else { //May only happen for testing, warn otherwise
                log.warn("Provisioning target generated without an assignment id.");
                ProvisioningTarget target = new ProvisioningTarget();
                target.addAccountSelection(links, sourceRole);
                _targets.add(target);
            }
        }
    }

    /**
     * Return true if the project has any accounts selections that need to
     * be selected.
     */
    public boolean hasUnansweredAccountSelections() {
        Collection<AccountSelection> selections = getAccountSelections();
        if (!Util.isEmpty(selections)) {
            for (AccountSelection selection : selections) {
                if (!selection.isImplicitCreate() && !selection.isDoCreate() && Util.isEmpty(selection.getSelectedNativeIdentities())) {
                    return true;
                }
            }
        }
        return false;
    }

    //////////////////////////////////////////////////////////////////////
    //
    // ProvisioningTarget Management
    //
    // This is the 6.3 replacement for _accountSelections but we have
    // to keep the other around for backward compatibility with in flight
    // workflows after the upgrade.  Eventually we can remove 
    // _accountSelections.
    //
    //////////////////////////////////////////////////////////////////////

    /**
     * Return true if the project has any accounts selections that need to
     * be selected. This is used to conditionalize the execution
     * of the workflow step that presents the account selection forms.
     */
    public boolean hasUnansweredProvisioningTargets() {
        boolean unanswered = false;
        if (_targets != null) {
            for (ProvisioningTarget target : _targets) {
                if (!target.isAnswered()) {
                    unanswered = true;
                    break;
                }
            }
        }
        return unanswered;
    }

    public void addProvisioningTarget(ProvisioningTarget targ) {
        if (targ != null) {
            if (_targets == null)
                _targets = new ArrayList<ProvisioningTarget>();
            _targets.add(targ);
        }
    }

    /**
     * Search for a ProvisioningTarget given an assignment id.
     * @ignore
     * This should eventually replace the two methods above.
     */
    public ProvisioningTarget getProvisioningTarget(String id) {
        ProvisioningTarget found = null;
        if (_targets != null) {
            for (ProvisioningTarget t : _targets) {
                if (id.equals(t.getAssignmentId())) {
                    found = t;
                    break;  
                }
            }
        }
        return found;
    }

    /**
     * Search for a provisioning target for the given role.
     * If there is more than one, return the first one.
     * 
     * @ignore
     * This is necessary for backward compatibility with 
     * RoleAssignments that have not been upgraded to have
     * assignmentIds.  We generate new ones, but since we 
     * can't upgrade the Identity during plan compilation we have
     * to have a way to get back using only the role name.  This
     * is only allowed in plans that have a single role assignment.
     */
    public ProvisioningTarget getProvisioningTarget(Bundle role) {
        ProvisioningTarget found = null;
        if (_targets != null) {
            for (ProvisioningTarget t : _targets) {
                if (role.getName().equals(t.getRole())) {
                    found = t;
                    break;  
                }
            }
        }
        return found;
    }

    //////////////////////////////////////////////////////////////////////
    //
    // ExpansionItem Management
    //
    //////////////////////////////////////////////////////////////////////

    /**
     * Check if the expansion item is a secret value
     * @param item ExpansionItem to check
     * @return boolean true if the related AttributeRequest has ARG_SECRET set to true
     */
    public boolean isExpansionSecret(ExpansionItem item) {
        if (item == null) {
            return false;
        }
        AttributeRequest request = findMatchingAttributeRequest(item);
        return (request != null && request.getBoolean(ProvisioningPlan.ARG_SECRET));
    }

    /**
     * Add an ExpansionItem to this project. The caller is responsible for
     * preventing duplicates.
     */
    public void addExpansionItem(ExpansionItem item) {
        if (null == _expansionItems) {
            _expansionItems = new ArrayList<ExpansionItem>();
        }
        _expansionItems.add(item);
        addItemCache(item);
    }
    
    /**
     * Return a matching expansion item. This is not specific to a native
     * identity.
     * 
     * @see #getExpansionItem(String, String, String, String, Object)
     */
    public ExpansionItem getExpansionItem(String app, String attr, Object value) {
        ExpansionItem found = null;

        if (null != _expansionItems) {
            for (ExpansionItem curr : _expansionItems) {
                if (Util.nullSafeEq(app, curr.getApplication(), true) &&
                    Util.nullSafeEq(attr, curr.getName(), true) &&
                    Util.nullSafeEq(value, curr.getValue(), true)) {

                    found = curr;
                    break;
                }
            }
        }

        return found;
    }

    /**
     * Return a matching expansion item.
     */
    public ExpansionItem getExpansionItem(String app, String instance,
                                          String nativeIdentity, String attr,
                                          Object value) {
        return getExpansionItem(app, instance, nativeIdentity, attr, value, null, false, true);
    }

    /**
     * Return a matching ExpansionItem in this project.
     * If ignoreNullNativeIdentity is true, an expansion is returned if
     * everything matches except for a null native identity on the item in the
     * the project.  This is used to update existing expansions that might have
     * been added before a native identity was calculated through account
     * selection.
     */
    public ExpansionItem getExpansionItem(ExpansionItem item,
                                          boolean ignoreNullNativeIdentity) {
        return getExpansionItem(item.getApplication(), item.getInstance(),
                                item.getNativeIdentity(), item.getName(),
                                item.getValue(), item.getSourceInfo(),
                                ignoreNullNativeIdentity, false);
    }
    
    /**
     * Return an ExpansionItem for the given AccountRequest and GenericRequest.
     * Since GenericRequests may contain multiple values, the caller must pass
     * in which value they are concerned with. This returns null if no
     * expansion is found that matches.
     */
    public ExpansionItem getExpansionItem(AccountRequest acctReq,
                                          GenericRequest req,
                                          Object value) {
        return getExpansionItem(acctReq.getApplication(), acctReq.getInstance(),
                                acctReq.getNativeIdentity(), req.getName(),
                                value, null, false, true);
    }

    /**
     * Return a matching expansion item.
     */
    private ExpansionItem getExpansionItem(String app, String instance,
                                           String nativeIdentity, String attr,
                                           Object value, String source,
                                           boolean ignoreNullNativeIdentity,
                                           boolean ignoreSource) {

        buildItemCache();
        List<ExpansionItem> items = _itemCache.get(getItemKey(value));
        return getExpansionItemCached(app, instance, nativeIdentity, attr, source,
                ignoreNullNativeIdentity, ignoreSource, items);
    }

    /**
     * Get the item cache key for a value.
     * This is expected to be a single value, usualy a String, possibly an int or boolean.
     * If it is null, the key will also be null.
     * If it is a collection, which I don't think can happen with expansion items,
     * we just toString the collection, since I'm not sure what a List key in a HashMap will do.
     */
    private Object getItemKey(Object value) {
        Object key = value;
        if (value instanceof Collection)
            key = value.toString();
        return key;
    }

    /**
     * Look for an expansion item on a list, normally from the cache.
     * Since the cache is keyed by value we don't need to compare the values.
     */
    private ExpansionItem getExpansionItemCached(String app, String instance,
                                                 String nativeIdentity, String attr,
                                                 String source, boolean ignoreNullNativeIdentity,
                                                 boolean ignoreSource,
                                                 List<ExpansionItem> items) {
        ExpansionItem found = null;

        for (ExpansionItem item : Util.iterate(items)) {

            boolean idsEqual =
                Util.nullSafeEq(nativeIdentity, item.getNativeIdentity(), true) ||
                (ignoreNullNativeIdentity && (null == item.getNativeIdentity()));

            // Add sourceInfo to comparison if ignoreSource is false
            boolean sourceEqual = ignoreSource ||
                    Util.nullSafeEq(source, item.getSourceInfo(), true);

            if (idsEqual && sourceEqual &&
                Util.nullSafeEq(app, item.getApplication(), true) &&
                Util.nullSafeEq(instance, item.getInstance(), true) &&
                Util.nullSafeEq(attr, item.getName(), true)) {

                found = item;
                break;
            }
        }
        return found;
    }

    /**
     * Build the expansion item cache.
     */
    private void buildItemCache() {
        if (_itemCache == null) {
            _itemCache = new HashMap<Object,List<ExpansionItem>>();
            for (ExpansionItem item : Util.iterate(_expansionItems)) {
                addItemCache(item);
            }
        }
    }

    private void addItemCache(ExpansionItem item) {
        if (_itemCache != null) {
            Object key = getItemKey(item.getValue());
            List<ExpansionItem> items = _itemCache.get(key);
            if (items == null) {
                items = new ArrayList<ExpansionItem>();
                _itemCache.put(key, items);
            }
            items.add(item);
        }
    }
    
    /**
     * Remove any ExpansionItems that are no longer in the plans.
     */
    public void cleanupExpansionItems() {
        if (!Util.isEmpty(_expansionItems) && !Util.isEmpty(_plans)) {
            Iterator<ExpansionItem> it = _expansionItems.iterator();
            while (it.hasNext()) {
                ExpansionItem item = it.next();
                boolean found = existsInPlans(item);

                // Did not find this in the plans - remove it.
                if (!found) {
                    it.remove();
                }
            }

            // If there aren't left, null out the list.
            if (Util.isEmpty(_expansionItems)) {
                _expansionItems = null;
            }
        }
    }

    /**
     * Return whether the given ExpansionItem exists in any of the plans.
     */
    @SuppressWarnings("unchecked")
    private boolean existsInPlans(ExpansionItem item) {
        for (ProvisioningPlan plan : _plans) {
            List<AccountRequest> acctReqs =
                plan.getAccountRequests(item.getApplication());
            for (AccountRequest acctReq : acctReqs) {
                List<AttributeRequest> attrReqs =
                    acctReq.getAttributeRequests(item.getName());
                if (!attrReqs.isEmpty()) {
                    for (AttributeRequest attrReq : attrReqs) {
                        List<Object> vals = Util.asList(attrReq.getValue());
                        if ((null != vals) && vals.contains(item.getValue())) {
                            return true;
                        }
                    }
                }
                else {
                    List<PermissionRequest> permReqs =
                        acctReq.getPermissionRequests(item.getName());
                    for (PermissionRequest permReq : permReqs) {
                        List<String> rights = permReq.getRightsList();
                        if ((null != rights) && rights.contains(item.getValue())) {
                            return true;
                        }
                    }
                }
            }
        }

        return false;
    }

    /**
     * Find the matching attribute request
     *
     * @param item ExpansionItem to find
     * @return GenericRequest request that matches the expansion item
     */
    private AttributeRequest findMatchingAttributeRequest(ExpansionItem item) {
        for (ProvisioningPlan plan : Util.safeIterable(_plans)) {
            List<AccountRequest> acctReqs = plan.getAccountRequests(item.getApplication());
            for (AccountRequest acctReq : Util.safeIterable(acctReqs)) {
                AttributeRequest attributeRequest = acctReq.getAttributeRequest(item.getName());
                if (attributeRequest != null) {
                    return attributeRequest;
                }
            }
        }

        return null;
    }
    
    //////////////////////////////////////////////////////////////////////
    //
    // Identity/Link Value Retrieval
    //
    //////////////////////////////////////////////////////////////////////

    /**
     * Return the requested attribute from the identity. This will first
     * try to retrieve a modified value from this project, and if not found
     * will try to get the value from the identity.
     */
    public Object getIdentityAttribute(String attrName, Identity identity) {

        List<AttributeRequest> attrReq = null;
        
        // First check the expanded plan.
        ProvisioningPlan plan = getIIQPlan();
        if ((null != plan) && !Util.isEmpty(plan.getAccountRequests())) {
            AccountRequest acctReq = plan.getAccountRequests().get(0);
            attrReq = acctReq.getAttributeRequests(attrName);
        }

        // Not expanded yet - try the master.
        if (null != attrReq) {
            AccountRequest acctReq = _masterPlan.getIIQAccountRequest();
            if (null != acctReq) {
                attrReq = acctReq.getAttributeRequests(attrName);
            }
        }

        Object current = identity.getAttribute(attrName);
        return applyAttributeRequest(attrReq, current);
    }

    /**
     * This could possibly return an attribute that is a random attribute from
     * any one of a link on the same application, so it is best not to use this.
     * @param appName Application name
     * @param attrName Attribute name
     * @param identity Identity target
     * @return Possibly return a requested link attribute value for this identity.
     * @deprecated use {@link #getLinkAttribute(String, String, String, String, sailpoint.object.ProvisioningPlan.AbstractRequest, Identity)}
     */
    @Deprecated
    public Object getLinkAttribute(String appName, String attrName,
                                   Identity identity) {
        return getLinkAttribute(appName, null, null, attrName, null, identity);
    }
    
    /**
     * Return the requested link attribute value for this identity. This will
     * first try to retrieve a modified value from this project, and if not
     * found will try to get the value from the identity.  The
     * operation is checked to be sure that it is not looking for an existing link when
     * performing a create.
     * 
     * If no request is provided, the existing links are checked. If a request
     * is provided, but it is a create, then the existing links are not checked.
     * Providing a null instance or null nativeIdentity will not prevent
     * searching for an existing value on a link.
     * 
     * @param appName Name of the Link's application
     * @param nativeIdentity The Link's native identity on the application
     * @param instance Instance that the Link is on.  This is often null 
     *                 because instances are optional.
     * @param attrName Name of the attribute that the link corresponds to
     * @param request AccountRequest or ObjectRequest containing the potentially modified Link.
     *                If this is null then existing Links will be searched
     * @param identity Identity to which the Link belongs
     * @return The link attribute value corresponding to the specified criteria
     */
    public Object getLinkAttribute(String appName, String nativeIdentity, String instance,
            String attrName, AbstractRequest request, Identity identity) {
        return getLinkAttribute(appName, nativeIdentity, instance, attrName, request, identity, false);
    }

    /**
     * This is the same as the {@link #getLinkAttribute(String, String, String, String, sailpoint.object.ProvisioningPlan.AbstractRequest, Identity)} method with
     * the addition of an option to limit the LinkAttribute search to the project's master plan.
     * This is necessary because expansion will sometimes wipe out values that were specified
     * via forms in Custom QuickLinks.
     * 
     * @param appName Name of the Link's application
     * @param nativeIdentity The Link's native identity on the application
     * @param instance Instance that the Link is on.  This is often null 
     *                 because instances are optional.
     * @param attrName Name of the attribute that the link corresponds to
     * @param request AccountRequest or ObjectRequest containing the potentially modified Link.
     *                If this is null then existing Links will be searched
     * @param identity Identity to which the Link belongs
     * @param masterOnly true if the search should be limited to the master plan for the project; false otherwise
     *                   In most cases this will be false.  The search will only be limited to the master plan in 
     *                   cases where expansion may have wiped out a hard-coded value from a custom QuickLink.
     * @return The link attribute value corresponding to the specified criteria
     * @see #getLinkAttribute(String, String, String, String, sailpoint.object.ProvisioningPlan.AbstractRequest, Identity)
     */
    public Object getLinkAttribute(String appName, String nativeIdentity, String instance,
                                   String attrName, AbstractRequest request, Identity identity,
                                   boolean masterOnly) {
        return getLinkAttribute(appName, nativeIdentity, instance, attrName, request, identity, masterOnly, false);
    }
        
    /**
     * This is the same as the {@link #getLinkAttribute(String, String, String, String, sailpoint.object.ProvisioningPlan.AbstractRequest, Identity)} method with
     * the addition of one option to limit the LinkAttribute search to the project's master plan.
     * This is necessary because expansion will sometimes wipe out values that were specified
     * via forms in Custom QuickLinks. Another option allows one to direct the seartch to only use
     * the project's requests and not any existing account Link.
     * 
     * @param appName Name of the Link's application
     * @param nativeIdentity The Link's native identity on the application
     * @param instance Instance that the Link is on.  This is often null 
     *                 because instances are optional.
     * @param attrName Name of the attribute that the link corresponds to
     * @param request AccountRequest or ObjectRequest containing the potentially modified Link.
     *                If this is null then existing Links will be searched
     * @param identity Identity to which the Link belongs
     * @param masterOnly true if the search should be limited to the master plan for the project; false otherwise
     *                   In most cases this will be false.  The search will only be limited to the master plan in 
     *                   cases where expansion may have wiped out a hard-coded value from a custom QuickLink.
     * @param requestOnly true if the search should be limited to account and attribute requests; false to also include
     *                   existing Link data
     * @return The link attribute value corresponding to the specified criteria
     * @see #getLinkAttribute(String, String, String, String, sailpoint.object.ProvisioningPlan.AbstractRequest, Identity)
     */
    public Object getLinkAttribute(String appName, String nativeIdentity, String instance,
                String attrName, AbstractRequest request, Identity identity,
                boolean masterOnly, boolean requestOnly) {


        List<AttributeRequest> attrReq = null;

        // First check the expanded plan.
        // There are times when we want to limit our search to the master.  See bug 20927 for details.
        if (!Util.isEmpty(_plans) && !masterOnly) {
            for (ProvisioningPlan plan : _plans) {
                List<AccountRequest> acctReqs = plan.getAccountRequests(appName, nativeIdentity);
                attrReq = getAttributeRequests(acctReqs, attrName);
                if (null != attrReq) {
                    break;
                }
            }
        }

        // Not expanded yet - try the master.
        if (null == attrReq) {
            List<AccountRequest> acctReqs = _masterPlan.getAccountRequests(appName);
            attrReq = getAttributeRequests(acctReqs, attrName);
        }

        // Grab the current value from the identity.
        // Don't do this if this is a create operation.  We don't need to look
        // at existing links for a create.
        Object current = null;
        if (!requestOnly && (null == request || !ProvisioningPlan.ObjectOperation.Create.equals(request.getOp()))) {
            // don't do this if we know we're creating.
            if (!Util.isEmpty(identity.getLinks())) {
                for (Link link : identity.getLinks()) {
                    // If the app matches &&
                    // nativeIdentity is provided and matches &&
                    // instance is provided and matches, then use the attr from this link.
                    // Note that if the identity has multiple accounts on the same app,
                    // and nativeIdentity/instance are not provided, we may match
                    // any of the identity's links on that app.
                    if (appName.equals(link.getApplication().getName()) &&
                        (Util.isNullOrEmpty(nativeIdentity) || nativeIdentity.equals(link.getNativeIdentity())) &&
                        (Util.isNullOrEmpty(instance) || instance.equals(link.getInstance()))) {
                        
                        current = link.getAttribute(attrName);
                        if (null != current) {
                            break;
                        }
                    }
                }
            }
        }

        return applyAttributeRequest(attrReq, current);
    }

    /**
     * Return the requested attribute value for this group. This will
     * first try to retrieve a modified value from this project, and if not
     * found will try to get the value from the ManagedAttribute.
     */
    public Object getObjectAttribute(String appName, String attrName,
                                     ManagedAttribute object) {

        ObjectRequest oreq = null;
        List<AttributeRequest> areq = null;

        // First check the expanded plan.
        if (!Util.isEmpty(_plans)) {
            for (ProvisioningPlan plan : _plans) {
                oreq = getRequest(plan, object);
                if (oreq != null)
                    break;
            }
        }

        // Not expanded yet - try the master.
        if (oreq == null)
            oreq = getRequest(_masterPlan, object);

        if (oreq != null)
            areq = oreq.getAttributeRequests(attrName);

        // Grab the current value from the identity.
        Object current = object.get(attrName);

        return applyAttributeRequest(areq, current);
    }

    /**
     * Look for an AttributeRequest in a plan that would target
     * the given ManagedAttribute.
     */
    private ObjectRequest getRequest(ProvisioningPlan plan, ManagedAttribute att) {

        ObjectRequest found = null;
        List<ObjectRequest> oreqs = plan.getObjectRequests();
        if (oreqs != null) {
            for (ObjectRequest oreq : oreqs) {

                // veil 1: application
                Application app = att.getApplication();
                if (app != null && app.getName().equals(oreq.getApplication())) {

                    // veil 2: attribute
                    // must be using the new convention
                    String ref = null;
                    AttributeRequest ar = oreq.getAttributeRequest(ManagedAttribute.PROV_ATTRIBUTE);
                    if (ar != null) {
                        Object v = ar.getValue();
                        if (v != null)
                            ref = v.toString();
                    }
                    if (ref != null && ref.equals(att.getAttribute())) {
                        // veil 2: value
                        String id = oreq.getNativeIdentity();
                        if (id != null && id.equals(att.getValue())) {

                            found = oreq;
                            break;
                        }
                    }
                    // veil 3: Compare objectType/value
                    if (Util.nullSafeEq(att.getType(), oreq.getType(), false)) {
                        String id = oreq.getNativeIdentity();
                        if (Util.nullSafeEq(id, att.getValue(), false)) {
                            found = oreq;
                            break;
                        }
                    }
                }
            }
        }
        return found;
    }

    /**
     * Return the first AttributeRequest that is found with the given name from
     * the given AccountRequests. Note that multiple AccountRequests can
     * contain an AttributeRequest for the requested attribute.  This is a 
     * best effort here since the caller typically will not know the
     * nativeIdentity they are looking for (this is usually called from rules
     * in provisioning policies where the context is generic).
     */
    private AttributeRequest getAttributeRequest(List<AccountRequest> acctReqs,
                                                 String attrName) {
        if (null != acctReqs) {
            for (AccountRequest acctReq : acctReqs) {
                AttributeRequest attrReq = acctReq.getAttributeRequest(attrName);
                if (null != attrReq) {
                    return attrReq;
                }
            }
        }
        return null;
    }
    
    /**
     * Return all AttributeRequest that are found with the given name from the 
     * given AccountRequests
     */
    private List<AttributeRequest> getAttributeRequests(List<AccountRequest> acctReqs, String attrName) {
        if (null != acctReqs) {
            for (AccountRequest acctReq : acctReqs) {
                List<AttributeRequest> attrReq = acctReq.getAttributeRequests(attrName);
                if (null != attrReq) {
                    return attrReq;
                }
            }
        }
        return null;
    }
    /**
     * Return the result of applying the given AttributeRequest to the given
     * attribute value. If the request is null, the current value is returned.
     */
    @SuppressWarnings("unchecked")
    private static Object applyAttributeRequest(List<AttributeRequest> attrReqs,
                                                Object current) {
        
        // Do nothing if there is no request.
        if (null == attrReqs) {
            return current;
        }
        
        Object currentCopy = current;
        if (current instanceof List) {
            currentCopy = new ArrayList();
            ((List) currentCopy).addAll((List) current);
        }
        
        for(AttributeRequest attrReq : attrReqs) {
            Object newVal = attrReq.getValue();
            Operation op = attrReq.getOperation();
            if (null == op) {
                // missing ops are common, assume Set
                op = Operation.Set;
            }
            
            switch (op) {
            case Add:
                currentCopy = ProvisioningPlan.addValues(newVal, currentCopy);
                break;   
    
            case Retain:
                currentCopy = ProvisioningPlan.retainValues(newVal, currentCopy, false);
                break;
    
            case Set:
                currentCopy = newVal;
                break;
    
            case Remove:
            case Revoke:
                currentCopy = ProvisioningPlan.removeValues(newVal, currentCopy);
                break;
    
            default:
                throw new RuntimeException("Unknown operation: " + op);
            }
        }

        return currentCopy;
    }

    /**
     * Returns a Create or Modify request in the project for the given application
     * @param application Application whose Create request we want to obtain
     * @return AccountRequest with a Create or Modify operation on the specified application.
     *         Returns null if no such request is found.
     */
    public AccountRequest getCreateOrModifyRequest(Application application) {
        for (ProvisioningPlan plan : Util.iterate(_plans)) {
            for (AccountRequest acctReq : Util.iterate(plan.getAccountRequests())) {
                AccountRequest.Operation op = acctReq.getOperation();
                // At this point (pre-template processing) we may have
                // modify requests that will later be turned into
                // create requests.  So return true if we find either.
                if ((AccountRequest.Operation.Create.equals(op) ||
                        AccountRequest.Operation.Modify.equals(op)) &&
                        application.getName().equals(acctReq.getApplication())) {
                    return acctReq;
                }
            }
        }
        return null;
    }
    
    /**
     * 
     * Go through the managed plans and see if the plans have been 
     * executed.
     * 
     * This is needed for dependencies where a call is made to see if
     * anything needs to be executed.
     * 
     * @return True if any plans have not been executed or need a retry.
     */
    public boolean hasUnfinishedIntegrationPlans() {        
        List<ProvisioningPlan> plans = this.getIntegrationPlans();
        if ( plans != null ) {
            for ( ProvisioningPlan plan : plans ) {
                if ( plan == null ) {
                    continue;
                }               
                if ( !plan.hasBeenExecuted() && !plan.needsRetry() ) {
                    return true;
                }
                
            }
        }        
        return false;        
    }

    //Check if all plans in the project are committed
    //Returns false of any of the plan is not committed
    public boolean isFullyCommitted() {
        for (ProvisioningPlan plan : Util.iterate(_plans)) {
            //if plan is for IIQ (for removing assignments in case of delete role event), assume its committed
            if (!plan.isIIQ() && plan.getTargetIntegration() != null && !plan.isFullyCommitted()) {
                return false;
            }
        }

        return true;
    }
    

    //Traverse all plans in the project and return the error message 
    //from provisioning result if any
    public List<Message> getErrorMessages() {

        List<Message> errors = new ArrayList<Message>();

        for (ProvisioningPlan plan: Util.iterate(_plans)) {
            ProvisioningResult result = plan.getResult();

            // if the plan has no result, the default status is queued
            String planStatus = ProvisioningResult.STATUS_QUEUED;
            if (result != null && result.getStatus() != null)
                planStatus = result.getStatus();


            List<AccountRequest> accounts = plan.getAccountRequests();

            for (AccountRequest account : Util.iterate(accounts)) {

                int itemFailures = 0;

                // If all the items succeed then the account request succeeds
                // unless it has an explicit result and an op that may do
                // more than what the AttributeRequests did (enable/disable).
                // This case is so obscure, I'm just assuming that if a local
                // result is provided it wins.
                ProvisioningResult accountResult = account.getResult();
                if (accountResult != null && !accountResult.isCommitted() && !Util.isEmpty(accountResult.getErrors())) {
                    errors.addAll(accountResult.getErrors());
                }
                else {
                    String accountStatus = planStatus;
                    if (accountResult != null && accountResult.getStatus() != null)
                        accountStatus = accountResult.getStatus();

                    List<AttributeRequest> atts = account.getAttributeRequests();

                    for (AttributeRequest att : Util.iterate(atts)) {
                        String itemStatus = accountStatus;
                        ProvisioningResult ires = att.getResult();
                        if (ires != null && ires.getStatus() != null) {
                            itemStatus = ires.getStatus();

                            if (!ProvisioningResult.STATUS_COMMITTED.equals(itemStatus)) {
                                itemFailures++;
                                // one is enough
                                if (!Util.isEmpty(ires.getErrors())) {
                                    errors.addAll(ires.getErrors());
                                }
                            }
                        }
                    }

                    if (itemFailures == 0) {
                        List<PermissionRequest> perms = account.getPermissionRequests();

                        for (PermissionRequest perm : Util.iterate(perms)) {
                            String itemStatus = accountStatus;
                            ProvisioningResult ires = perm.getResult();
                            if (ires != null && ires.getStatus() != null) {
                                itemStatus = ires.getStatus();

                                if (!ProvisioningResult.STATUS_COMMITTED.equals(itemStatus)) {
                                    itemFailures++;

                                    if (!Util.isEmpty(ires.getErrors())) {
                                        errors.addAll(ires.getErrors());
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }

        return errors;
    }
}
