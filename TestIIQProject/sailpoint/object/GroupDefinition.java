/* (c) Copyright 2008 SailPoint Technologies, Inc., All Rights Reserved. */

/**
 * A class defining an identity group type.
 * 
 * Author: Jeff
 * 
 * Group types are not themselves groups of identities, they
 * describe how to *materialize* the groups of identities.  For example
 * a common group type will be "Department" which means that we first
 * must determine the set of all departments, then the set of identities
 * in each department, then an aggregate scorecard for each department.
 * Other examples of group types include: Organization, Location,
 * Business Unit, and Manager.
 *
 * Group types are usually defined by selecting an identity attribute
 * whose values will be the names of the materialized groups.
 *
 * A special group type called a "singleton" may also be defined.  In
 * a singleton, a single group is specified using an arbitrary search
 * filter for identities.  Any identities matching the filter are considered
 * to be members of the group.  
 *
 * When necessary to distinguish between these two styles of group definition
 * the terms "factory" and "singleton" will be used.
 *
 * The SailPointObject._name field will be the unique name of the group type.
 * For multiplicitive types, it wil be things like Department and Location.
 * For singleton types, it should be a name describing the filter, such
 * as "High Risk" or "Habitual Policy Violators".
 *
 * GroupDefinitions are consumed by a "generator" that materializes
 * the groups.  There is no formal interface for the generator or what
 * it produces.  Currently we have only one generator, the Scorekeeper, that
 * will use GroupDefinitions to generate GroupIndex objects containing
 * score statitics about the group members.  
 *
 * In theory though, we could use GroupDefinitions for other things
 * like reporting and authorization.  If we start doing that, the
 * model may need to evolve to either support "tagging" of GroupDefinitions
 * for a specific purpose (generator) or configuring the generators
 * with lists of GroupDefinitions.  
 *
 */

package sailpoint.object;

import java.util.Date;
import java.util.LinkedHashMap;
import java.util.Map;

import sailpoint.tools.GeneralException;
import sailpoint.tools.xml.SerializationMode;
import sailpoint.tools.xml.XMLClass;
import sailpoint.tools.xml.XMLProperty;

/**
 * A class defining a group of identities.
 *
 * These are used for what the UI calls "populations" as well
 * as the groups automatically generated by group factories.
 */
@XMLClass
public class GroupDefinition extends SailPointObject implements Cloneable
{

    //////////////////////////////////////////////////////////////////////
    //
    // Constants
    //
    //////////////////////////////////////////////////////////////////////

    // Bug 21737 - We want to overwrite an existing GroupDefinition with the 
    // same name and same GroupFactory (or both have no GroupFactory) and allow 
    // duplicate GroupDefinitions where the names are the same but have a different 
    // GroupFactory (or both have no GroupFactory). 
    private static final String[] UNIQUE_KEY_PROPERTIES =
            new String[] { "name", "factory" };

    //////////////////////////////////////////////////////////////////////
    //
    // Fields
    //
    //////////////////////////////////////////////////////////////////////

    /**
     * The name of the factory. Can be null for ad-hoc groups
     * created to represent iPOPs.
     */
    GroupFactory _factory;

    /**
     * The filter that selects the identities in this group.
     */
    Filter _filter;

    /**
     * When true, the identities in the group are considered
     * to have a null value for the factory attribute. This
     * is set only for factory groups as a hint to the UI that
     * it should not display the name of the definition but
     * instead show some localized "No Value" label. You can
     * derive this by looking at the Filter, but its more reliable
     * just to set it.
     */
    boolean _nullGroup;

    /**
     * The date this group type was last refreshed.
     */
    Date _lastRefresh;

    // 
    // Group actions
    // It would be nice to have a more extensible mechanism to 
    // associate groups with actions, but for now we'll inline them
    // since there aren't very many.
    //

    /**
     * When true, GroupIndexes are generated for this group
     * when refreshed.
     */
    boolean _indexed;
    
    /**
     * When true, only the owner of this GroupDefinition can edit/use/delete
     * this object.
     */
    boolean _private;

    /**
     * The most recent index calculate for this group.
     * Normally set only if _indexed is true.
     * In theory the application should be able to derive
     * this by searching for all indexes with this definition
     * and picking off the most recent one, but since this can be maintained
     * reliably the search overhead can be avoided.
     */
    GroupIndex _index;

    //////////////////////////////////////////////////////////////////////
    //
    // Constructor
    //
    //////////////////////////////////////////////////////////////////////
    
    public GroupDefinition() {
    }

    public void visit(Visitor v) throws GeneralException {
        v.visitGroupDefinition(this);
    }

    //////////////////////////////////////////////////////////////////////
    //
    // Properties
    //
    //////////////////////////////////////////////////////////////////////

    /**
     * For factory groups,the factory attribute value is saved as the
     * name but this is not necessarily unique. For user defined groups 
     * enforce name uniqueness could be enforced, but if these are to be
     * scoped according to ownership then the names might not be unique
     * across all owners.
     */
    @Override
    public boolean hasName() {
        return true;
    }

    @Override
    public boolean isNameUnique() {
        return false;
    }

    /**
     * @exclude 
     * This is one of the few classes to overload getUniqueKeyProperties() in
     * order to specify a set of unique criteria that prevents duplication if 
     * you load XML files full of GroupDefinitions that do not have ids. We 
     * want to overwrite an existing GroupDefinition with the same name and
     * same GroupFactory (or both with no GroupFactory) and allow duplicate 
     * GroupDefinitions where the names are the same but have a different 
     * GroupFactory. 
     * Bug 21737 
     */
    public String[] getUniqueKeyProperties() {
        return UNIQUE_KEY_PROPERTIES;
    }

    @XMLProperty(mode=SerializationMode.REFERENCE)
    public void setFactory(GroupFactory f) {
        _factory = f;
    }

    /**
     * The name of the factory. Might be null for ad-hoc groups
     * created to represent iPOPs.
     */
    public GroupFactory getFactory() {
        return _factory;
    }

    @XMLProperty(xmlname="GroupFilter")
    public void setFilter(Filter f) {
        _filter = f;
    }

    /**
     * The filter that selects the identities in this group.
     */
    public Filter getFilter() {
        return _filter;
    }

    @XMLProperty
    public void setNullGroup(boolean b) {
        _nullGroup = b;
    }

    /**
     * When true, the identities in the group are considered
     * to have a null value for the factory attribute. This
     * is set only for factory groups as a hint to the UI that
     * it should not display the name of the definition but
     * instead show some localized "No Value" label. You can
     * derive this by looking at the Filter, but its more reliable
     * just to set it.
     */
    public boolean isNullGroup() {
        return _nullGroup;
    }

    @XMLProperty
    public void setLastRefresh(Date d) {
        _lastRefresh = d;
    }

    /**
     * The date this group type was last refreshed.
     */
    public Date getLastRefresh() {
        return _lastRefresh;
    }

    @XMLProperty
    public void setIndexed(boolean b) {
        _indexed = b;
    }

    /**
     * When true, generate GroupIndexes for this group
     * when refreshed.
     */
    public boolean isIndexed() {
        return _indexed;
    }

    @XMLProperty(mode=SerializationMode.REFERENCE)
    public void setIndex(GroupIndex i) {
        _index = i;
    }

    /**
     * The most recent index calculate for this group.
     * Normally set only if the <code>indexed</code> property is true.
     */
    public GroupIndex getIndex() {
        return _index;
    }

    /**
     * When true, only the owner of this GroupDefinition can edit/use/delete
     * this object.
     */
    @XMLProperty
    public boolean isPrivate() {
        return _private;
    }

    public void setPrivate(boolean p) {
        this._private = p;
    }

    //////////////////////////////////////////////////////////////////////
    //
    // Utilities
    //
    //////////////////////////////////////////////////////////////////////
    

    /**
     * Override the default display columns for this object type.
     */
    public static Map<String, String> getDisplayColumns() {
        final Map<String, String> cols = new LinkedHashMap<String, String>();
        cols.put("id", "Id");
        cols.put("name", "Name");
        cols.put("factory", "Factory");
        return cols;
    }

    /**
     * Provide a display format for each line in the list of these objects.
     * This string is used by PrintWriter.format().
     *
     * @return a print format string
     */
    public static String getDisplayFormat() {
        return "%-34s %-24s %s\n";
    }

}
