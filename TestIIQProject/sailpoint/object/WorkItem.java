/* (c) Copyright 2008 SailPoint Technologies, Inc., All Rights Reserved. */

/**
 * An object describing an manual action to be performed
 * by a user.  These are typically displayed in an "inbox"
 * in the UI, users may then modify them and submit them,
 * submission may trigger side effects.
 * 
 * Author: Jeff, Kelly, and a cast of thousands
 * 
 * Work items will be of a particular type, represented as a 
 * constant rather than a subclass since the structure is 
 * otherwise identical.  These may be used by the UI to 
 * organize work items into multiple pages.
 *
 * Later the notion of a handler class was added to associate
 * behavior with the item, this makes the type somewhat
 * redundant so reconsider that someday.
 * 
 */

package sailpoint.object;

import java.util.ArrayList;
import java.util.Date;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;

import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;

import sailpoint.object.ProvisioningPlan.AccountRequest;
import sailpoint.server.WorkItemHandler;
import sailpoint.tools.BidirectionalCollection;
import sailpoint.tools.GeneralException;
import sailpoint.tools.Index;
import sailpoint.tools.Indexes;
import sailpoint.tools.Message;
import sailpoint.tools.MessageKeyHolder;
import sailpoint.tools.Util;
import sailpoint.tools.xml.SerializationMode;
import sailpoint.tools.xml.XMLClass;
import sailpoint.tools.xml.XMLProperty;
import sailpoint.web.certification.PolicyTreeNode;
import sailpoint.web.messages.MessageKeys;


@Indexes({@Index(name="spt_workitem_owner_type", property="owner"),
          @Index(name="spt_workitem_owner_type", property="type")
})
@XMLClass
public class WorkItem extends SailPointObject implements Cloneable, Notifiable, AssignableItem
{

    //////////////////////////////////////////////////////////////////////
    //
    // Constants
    //
    //////////////////////////////////////////////////////////////////////

    //
    // System defined attributes.
    // This is an alternative to using class fields which is not as
    // convenient from a programmer's perspective but has the distinct
    // advantage of not requiring a Hibernate schema upgrade every time you
    // add an attribute.  The tradeoff is that you can't search on these.
    // For approvals this may suck since we can't search for
    // WorkItems that are approving a given object without fetching them.
    //

    /**
     * 
     */
    private static final long serialVersionUID = -6989499333652799511L;

    /**
     * For work items with a related task result, the database id
     * of the result. Originally used to track impact analysis.
     * @ignore
     * TODO: When signoff support was added the _target family of fields
     * was added so impact analysis should starting using those now!!
     */
    public static final String ATT_TASK_RESULT = "taskResultId";

    /**
     * Form work items generated by workflow approvals with forms, 
     * this is a copy of the compiled approval form.  
     */
    public static final String ATT_FORM = "workItemForm";

    public static final String ATT_FORM_CHANGED = "isFormChanged";
    /**
     * For work items that do complex approvals, an ApprovalSet object
     * describing what is being approved.
     */
    public static final String ATT_APPROVAL_SET = "approvalSet";

    
    /**
     * An ElectronicSignature object for signed work items created
     * after signing.
     */
    public static final String ATT_SIGNATURE = "workItemSignature";

    /**
     * An attribute that specifies whether a WorkItemArchive is
     * created for this WorkItem when it is closed. This can
     * be set globally for work item types, or granularly for
     * each item. Normally this is set with an <Arg> in the <Approval>.
     */
    public static final String ATT_ARCHIVE = "workItemArchive";
    
    /**
     * An electronic signature type for this item.
     * This is set using an <Arg> and recognized by the page
     * renderer and Notary. If it is null there will be no signature.
     * If it is non-null it should be the generic "Approval" type
     * or one of the specialized types defined in 
     * Configuration:ElectronicSignature.
     */
    public static final String ATT_ELECTRONIC_SIGNATURE = "workItemElectronicSignature";
    
    /**
     * The Display name of the identity that completed the work item
     */
    public static final String ATT_COMPLETER = "workItemCompletedBy";

    /**
     * List of policy violation maps
     */
    public static final String ATT_POLICY_VIOLATIONS = "policyViolations";

    public static final String ATT_CHANGE_SUMMARY = "changes";
    public static final String ATT_SUMMARY_NAME = "summaryName";

    //////////////////////////////////////////////////////////////////////
    //
    // Enumerations
    //
    //////////////////////////////////////////////////////////////////////

    /**
     * Work item types.
     */
    @XMLClass(xmlname = "WorkItemType")
        public static enum Type implements MessageKeyHolder
        {
            Generic,
            Certification,
            Remediation,
            Delegation,
            Approval,
            // LCM Violation Review Workitem
            ViolationReview,
            Form,
            /**
             * Workitem generated by the Interrogator when
             * alerts are enabled for policy violations
             */
            PolicyViolation,
            Challenge,
            ImpactAnalysis,
            Signoff,
            Event,

            /**
             * WorkItem created by LCM for unmanaged plans.
             */
            ManualAction,

            Test;

            public String getMessageKey() {
                return "work_item_type_" + Util.splitCamelCase(this.name()).replace(" ","_").toLowerCase();
            }
        }
   
    /**
     * Work item significance levels. The absence of a level implies "normal".
     * 
     * @ignore
     * Thought about having a Normal member here, but then we have to deal with
     * consistency issues keeping _level non-null. May as well just have one way
     * to represent normal.
     */
    @XMLClass(xmlname = "WorkItemLevel")
        public static enum Level implements MessageKeyHolder
        {

            /**
             * Unimportant work item
             */
            Low,

            /**
             * Typical work item.
             */
            Normal,
            
            /**
             * Something of unusual significance. Might be expired or escalated. 
             * @ignore
             * Do we need more than one level?
             */
            High;

            public String getMessageKey() {
                return "work_item_level_" + this.name().toLowerCase();
            }
        }

    /**
     * Work item completion states.
     */
    @XMLClass(xmlname = "WorkItemState")
        public static enum State implements MessageKeyHolder
        {

            /**
             * The work item was finished normally.
             * For work items of type Approval, this indicates approval.
             */
            Finished,

            /**
             * The work item was rejected.
             * Currently used only with Approval work items.
             */
            Rejected,

            /**
             * The owner decided not to accept this work item. Note that this 
             * is semantically different than "reject" in an Approval item.  
             * It means that no action was taken or that the user had 
             * no opinion.
             */
            Returned,

            /**
             * The work item expired with no action taken.
             */
            Expired,
            
            /**
             * When an approval workitem is first created it will start in the pending state
             */
            Pending,

            /**
             * The work item was canceled with no user input.
             * This state should only be set by the workflow engine.
             */
            Canceled;

            public String getMessageKey() {
                return "work_item_state_" + this.name().toLowerCase();
            }

            /**
             * Returns a list of work item states to be shown in Form DropDowns.
             * This also includes the null state.
             */
            public static List<String> getWorkItemStatesList() {
                List list = new ArrayList();
                addOneState(list, Field.NULL_CONST, MessageKeys.WORK_ITEM_STATE_OPEN);
                for(State enumItem : State.values()) {
                    addOneState(list, enumItem.toString(), enumItem.getMessageKey());
                }
                return list;
            }

            /**
             * Adds one value to the list of state values
             * @param list the list
             * @param name name of the value
             * @param display the display to be shown in the dropdown
             */
            private static void addOneState(List list, String name, String display) {
                List list2 = new ArrayList();
                list2.add(name);
                list2.add(display);
                list.add(list2);
            }
        }

    private static enum WorkItemManagerAttributes {
        EscalationErrors
    }


    //////////////////////////////////////////////////////////////////////
    //
    // Inner Classes
    //
    //////////////////////////////////////////////////////////////////////

    /**
     * An entry in the forwarding history of a work item.
     */
    @XMLClass
    public static class OwnerHistory {
        private String oldOwner;
        private String oldOwnerDisplayName;
        private String newOwner;
        private String newOwnerDisplayName;
        private String comment;
        private Date startDate;

        /**
         * Person that change the ownership.
         */ 
        private String source;
        private String sourceDisplayName;

        public OwnerHistory() {}

        /**
         * Keeping this for backward compatibility
         * try and use the constructor that take the 
         * source if possible.
         */
        public OwnerHistory(Identity oldOwner, Identity newOwner, 
                            String comment) {

            this(oldOwner,newOwner,null,comment);
        }

        public OwnerHistory(Identity oldOwner, Identity newOwner, 
                            Identity source, String comment) {

            this.oldOwner = getName(oldOwner);
            this.oldOwnerDisplayName = getDisplayName(oldOwner);
            this.newOwner = getName(newOwner);
            this.newOwnerDisplayName = getDisplayName(newOwner);
            // don't store  the source remnants if they are the
            // same as the old owner.
            if ( source != null ) {
                String sourceName = getName(source);
                if ( Util.nullSafeCompareTo(sourceName, this.oldOwner) != 0 ) {
                    this.source = sourceName; 
                }
                String sourceDisplayName = getDisplayName(source);
                if ( Util.nullSafeCompareTo(sourceDisplayName,this.oldOwnerDisplayName) != 0 ) {
                    this.sourceDisplayName = sourceDisplayName;
                }
            }
            this.comment = comment;
            this.startDate = new Date();
        }

        private String getName(Identity ident) {
            return (ident != null) ? ident.getName() : null;
        }
        
        private String getDisplayName(Identity ident) {
            final String displayName;
            
            if (ident == null) {
                displayName = "";
            } else {
                displayName = ident.getDisplayableName();
            }
            
            return displayName;
        }

        @XMLProperty
        public String getNewOwner() {
            return newOwner;
        }

        public void setNewOwner(String newOwner) {
            this.newOwner = newOwner;
        }
        
        @XMLProperty
        public String getNewOwnerDisplayName() {
            return newOwnerDisplayName;
        }
        
        public void setNewOwnerDisplayName(String newOwnerDisplayName) {
            this.newOwnerDisplayName = newOwnerDisplayName;
        }

        @XMLProperty
        public String getOldOwner() {
            return oldOwner;
        }

        public void setOldOwner(String oldOwner) {
            this.oldOwner = oldOwner;
        }

        @XMLProperty
        public String getOldOwnerDisplayName() {
            return oldOwnerDisplayName;
        }
        
        public void setOldOwnerDisplayName(String oldOwnerDisplayName) {
            this.oldOwnerDisplayName = oldOwnerDisplayName;
        }

        @XMLProperty
        public String getSource() {
            return source;
        }

        public void setSource(String source) {
            this.source = source;
        }

        /**
         * Method that should be called if you want the person
         * that forwarded the workitem. This method
         * consults the source attribute and if null returns
         * the old owner.
         */
        public String getEffectiveSource() {
            if ( this.source != null ) 
                return this.source;
            else
                return this.oldOwner;    
        }

        @XMLProperty
        public String getSourceDisplayName() {
            return sourceDisplayName ;
        }
        
        public void setSourceDisplayName(String sourceDisplayName) {
            this.sourceDisplayName = sourceDisplayName;
        }

        /**
         * Method that should be called if you want the person
         * that forwarded the workitem. This method
         * consults the sourceDisplayName attribute and if null returns
         * the oldOwnerDisplayName.
         */
        public String getEffectiveSourceDisplayName() {
            if ( this.sourceDisplayName != null ) 
                return this.sourceDisplayName;
            else
                return this.oldOwnerDisplayName;    
        }

        @XMLProperty(mode=SerializationMode.ELEMENT, xmlname="OwnerHistoryComment")
            public String getComment() {
            return comment;
        }

        public void setComment(String comment) {
            this.comment = comment;
        }

        @XMLProperty
        public Date getStartDate() {
            return startDate;
        }

        public void setStartDate(Date startDate) {
            this.startDate = startDate;
        }

        //
        // Backward compatibility, upgrade References to names
        //

        /**
         * @deprecated use {@link #getNewOwner()}
         */
        @Deprecated
        @XMLProperty(mode=SerializationMode.REFERENCE,xmlname="NewOwner")
            public Identity getXMLNewOwner() {
            return null;
        }

        /**
         * @deprecated use {@link #setNewOwner(String)}
         */
        @Deprecated
        public void setXMLNewOwner(Identity identity) {
            if (identity != null)
                this.newOwner = identity.getName();
        }

        /**
         * @deprecated use {@link #getOldOwner()}
         */
        @Deprecated
        @XMLProperty(mode=SerializationMode.REFERENCE,xmlname="OldOwner")
            public Identity getXMLOldOwner() {
            return null;
        }

        /**
         * @deprecated use {@link #setOldOwner(String)}
         */
        @Deprecated
        public void setXMLOldOwner(Identity identity) {
            if (identity != null)
                this.oldOwner = identity.getName();
        }

    }

    //////////////////////////////////////////////////////////////////////
    //
    // Fields
    //
    //////////////////////////////////////////////////////////////////////

    private static final Log log = LogFactory.getLog(WorkItem.class);

    //
    // The inherited _description field will normally have a brief
    // description of what is being requested, suitable for display
    // in a table.
    //

    /**
     * The workflow that owns this item, if it was generated by a workflow.
     */
    WorkflowCase _workflow;

    /**
     * The work item type. This is used by the UI to determine which
     * pages to use to render the details of the item. It is also used
     * to select the handler to be notified when the object is persisted.
     */
    Type _type;

    /**
     * Class to be notified whenever a change to the work item is persisted.
     * The class must implement the sailpoint.server.WorkItemHandler interface.
     */
    String _handler;

    /**
     * Optional URL fragment to the JSF include that will render the
     * work item details. This path must be relative to the web/workItem
     * directory.  
     * @ignore
     * This is an experiment to try to let work items be
     * more customizable.  It handles the rendering adequately but
     * there are still issues on deciding which action buttons to display
     * and where the action handlers are located.  Ideally a WorkItem 
     * should be able to provide a list of the buttons it wants and
     * we should have a way to introduce custom backing beans to handle
     * the actions that plays nicely with WorkItemBean.  
     */
    String _renderer;

    /**
     * The completion state. For a work item to be considered completed, it must
     * be assigned one of these states. Lack of a completion state indicates
     * that the item is still active.
     */
    State _state;

    /**
     * Severity level of the item.
     */
    Level _level;

    /**
     * The user that is considered the originator of the work item. Might be null
     * for system generated items. Typically stays the same once set, but could
     * be modified during delegations.
     */
    Identity _requester;

    /**
     * The database object class of the associated object.
     * Work items are often associated with another object, the
     * combination of _targetClass and _targetId uniquely identifies
     * that object.  _targetName can also be set to the readable display
     * name of that object.
     * 
     * @ignore
     * This is currently used for Approval, Signoff, and PolicyViolation 
     * items.  Now that we have a general mechanism we should try to use
     * this instead of the _certification fields.
     */
    String _targetClass;

    /**
     * The unique database id of an associated object.
     * @see #_targetClass
     */
    String _targetId;

    /**
     * The optional display name of an associated object.
     * @see #_targetClass
     */
    String _targetName;

    /**
     * More verbose comments that describe what the owner of the work item is
     * supposed to do.
     */
    List<Comment> _comments;

    /**
     * Date the last notification was sent for this work item.
     */
    Date _notification;

    /**
     * Comments the owner can leave after completing the item. 
     * @ignore
     * Could overload _comments for this, but it may be useful to preserve them.
     */
    String _completionComments;

    /**
     * Date this work item expires. Upon expiration, we will send reminder
     * emails up to the limit specified by _maxReminders.
     * 
     * After a reminder the expiration is reset. The new expiration period is
     * taken from the global configuration, though each
     * WorkItem could carry its own refresh period.
     */
    Date _expiration;

    /**
     * Date that the next reminder will be sent out. Initially this will be set
     * to the expiration date. Each time a reminder is issued, this field will
     * be updated based on its reminder interval.
     */
    Date _wakeUpDate;

    /**
     * The number of reminder emails that have been sent for this item.
     */
    int _reminders;
    
    /**
     * The number of escalations for this item.
     */
    int _escalationCount = 0;

    /**
     * The configuration for reminders and escalations.
     */
    NotificationConfig _notificationConfig;
    
    /**
     * Arbitrary attributes.
     */
    // think: having a Signature on a WorkItem might be a useful
    // concept?
    Attributes<String, Object> _attributes;

    /**
     * A list containing the forwarding history of this work item.
     */
    List<OwnerHistory> _ownerHistory;

    // For now let's make work items rather specific to our domain and
    // give them top level fields that connect it to the rest of the
    // model rather than burying it as a name reference in the attributes map.
    // Not sure I want to mess with subclasses, but need to think
    // more about this.
    /**
     * Associated certification object ID. Stored as an ID because the
     * certification can be archived and deleted while work item still lives.
     */
    String _certification;

    /**
     * For delegations, the identity this Certification that are supposed to be dealt
     * with. Stored as an ID because the certification can be archived and
     * deleted while work item still lives.
     */
    // TODO: Should we allow more than one?
    String certificationEntity;

    CertificationEntity.Type _entityType;

    /**
     * For delegations, the items within this Certification that are supposed to be dealt
     *  with. Stored as an ID because the certification can be archived and
     * deleted while work item still lives.
     */
    // TODO: Should we allow more than one? It feels more likely we'll
    // want bulk item delegation.  This could be using the new generic 
    // _targetId field ?
    String _certificationItem;

    /**
     * For remediations, a list of remediation items that contain information
     * about the items to be remediated.
     */
    List<RemediationItem> _remediationItems;


    /**
     * Member of a workgroup who is currently working on this item.
     * Note that this is not the same as the owner. The assignee can
     * only be set when the workitem owner is a workgroup, and it has no
     * effect other than serving as a flag in the UI.
     */
    Identity _assignee;
    
    /**
     * The id of the IdentityRequest that caused this workitem.
     * This property can be null for workitems that are not
     * part of an IdentityRequest. 
     */
    String _identityRequestId;

    //////////////////////////////////////////////////////////////////////
    //
    // Constructors
    //
    //////////////////////////////////////////////////////////////////////

    public WorkItem()
        {}

    @Override
    public void visit(Visitor v) throws GeneralException {
        v.visitWorkItem(this);
    }

    /**
     * These can have names but they are optional and non-unique.
     */
    public boolean isNameUnique() {
        return false;
    }

    public static Map<String, String> getDisplayColumns() {
        final Map<String, String> cols = new LinkedHashMap<String, String>();
        cols.put("id", "Id");
        cols.put("name", "Work Item ID");
        cols.put("description", "Name");
        cols.put("owner.name", "Owner");
        return cols;
    }

    public static String getDisplayFormat() {
        return "%-34s %-20s %s\n";
    }

    /**
     * Load enough so this can be serialized.
     */
    public void load() {

        if (_requester != null) _requester.getName();
        if (_workflow != null) _workflow.getId();
        if (_remediationItems != null) {
            for (RemediationItem item : _remediationItems)
                item.load();
        }
        if (_comments != null) {
            for (Comment c : _comments) 
                c.getAuthor();
        }
        
        try {
            toXml(); // so callers can 'toXml()' later on
        } catch (GeneralException e) {
            log.error("Unable to load the workitem", e);
        } // ensures we an 'toXml' later
    }

    //////////////////////////////////////////////////////////////////////
    //
    // Properties
    //
    //////////////////////////////////////////////////////////////////////

    @XMLProperty(mode = SerializationMode.REFERENCE,xmlname="WorkflowCaseRef")
        public WorkflowCase getWorkflowCase()
        {
            return _workflow;
        }

    public void setWorkflowCase(WorkflowCase wf)
        {
            _workflow = wf;
        }

    @XMLProperty
    public void setType(Type type)
        {
            _type = type;
        }

    public Type getType()
        {
            return _type;
        }

    public boolean isType(Type t) {
        return (_type != null) ? _type.equals(t) : false;
    }

    @XMLProperty
    public void setHandler(String s)
        {
            _handler = s;
        }

    public String getHandler()
        {
            return _handler;
        }

    public void setHandler(Class c) {
        if (c != null) _handler = c.getName();
    }

    @XMLProperty
    public void setRenderer(String s)
    {
        _renderer = s;
    }

    public String getRenderer()
    {
        return _renderer;
    }

    @XMLProperty
    public void setState(State type)
    {
        _state = type;
    }

    public State getState()
    {
        return _state;
    }

    @XMLProperty
    public void setLevel(Level type)
    {
        _level = type;
    }

    public Level getLevel()
    {
        return _level;
    }

    @XMLProperty(mode = SerializationMode.REFERENCE)
    public Identity getRequester()
    {
        return _requester;
    }

    public void setRequester(Identity i)
    {
        _requester = i;
    }

    @XMLProperty
    public void setTargetClass(String name)
    {
        _targetClass = name;
    }

    public String getTargetClass()
    {
        return _targetClass;
    }

    @XMLProperty
    public void setTargetId(String id)
    {
        _targetId = id;
    }

    public String getTargetId()
    {
        return _targetId;
    }

    @XMLProperty
    public void setTargetName(String name)
    {
        _targetName = name;
    }

    public String getTargetName()
    {
        return _targetName;
    }

    @XMLProperty(mode = SerializationMode.LIST, xmlname = "WorkItemComments")
    public List<Comment> getComments()
    {
        return _comments;
    }

    public String getShortName(Resolver resolver) throws GeneralException
    {
        if (getType() == WorkItem.Type.Certification)
            return getCertification(resolver).getShortName();

        else if ((getType() == WorkItem.Type.Remediation)
                 || (getType() == WorkItem.Type.Delegation))
            return getDescription();

        else if (_type == WorkItem.Type.Approval || 
                 _type == WorkItem.Type.ImpactAnalysis)
            return getDescription();

        else if (getType() == WorkItem.Type.Challenge)
            return new String("Challenge for "
                              + getCertificationItem(resolver).getShortDescription());

        else {
            Identity owner = getOwner();
            String first = owner.getFirstname();
            String last = owner.getLastname();
            if (first != null && last != null)
                return new String("Work Item for " + getOwner().getLastname()
                                  + ", " + getOwner().getFirstname());
            else {
                return new String("Work Item for " + owner.getDisplayableName());
            }
        }
    }

    public void setComments(List<Comment> comments)
    {
        _comments = comments;
    }

    @XMLProperty(mode = SerializationMode.ELEMENT)
    public String getCompletionComments()
    {
        return _completionComments;
    }

    public void setCompletionComments(String s)
    {
        _completionComments = s;
    }

    @XMLProperty
    public void setNotification(Date d)
    {
        _notification = d;
    }

    public Date getNotification()
    {
        return _notification;
    }

    @XMLProperty
    public void setExpiration(Date d)
    {
        _expiration = d;
    }

    public Date getExpiration()
    {
        return _expiration;
    }

    @XMLProperty
    public void setWakeUpDate(Date d)
    {
        _wakeUpDate = d;
    }

    public Date getWakeUpDate()
    {
        return _wakeUpDate;
    }

    @XMLProperty
    public void setReminders(int i)
    {
        _reminders = i;
    }

    public int getReminders()
    {
        return _reminders;
    }

    @XMLProperty
    public void setEscalationCount(int i)
    {
        _escalationCount = i;
    }

    //@ Override http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=5008260
    public int getEscalationCount()
    {
        return _escalationCount;
    }
    
    //@ Override http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=5008260
    public void incrementEscalationCount()
    {
        _escalationCount++;
    }
    
    @XMLProperty(xmlname="NotifConfig")
    public void setNotificationConfig(NotificationConfig val)
    {
        _notificationConfig = val;
    }

    public NotificationConfig getNotificationConfig()
    {
        return _notificationConfig;
    }
    
    @XMLProperty(mode = SerializationMode.UNQUALIFIED)
    public Attributes<String, Object> getAttributes()
    {
        return _attributes;
    }

    public void setAttributes(Attributes<String, Object> a)
    {
        _attributes = a;
    }

    /**
     * Convenience method to ensure we have an attributes map.
     */
    public Attributes<String,Object> allocAttributes() {
        if (_attributes == null)
            _attributes = new Attributes<String,Object>();
        return _attributes;
    }

    @XMLProperty(mode = SerializationMode.INLINE_LIST_INLINE)
    public List<OwnerHistory> getOwnerHistory()
    {
        return _ownerHistory;
    }

    public void setOwnerHistory(List<OwnerHistory> history)
    {
        _ownerHistory = history;
    }

    public void addOwnerHistory(OwnerHistory history) {
        if (null == _ownerHistory) {
            _ownerHistory = new ArrayList<OwnerHistory>();
        }
        _ownerHistory.add(history);
    }

    @XMLProperty(xmlname = "WorkItemAssignee", mode = SerializationMode.REFERENCE)
    public Identity getAssignee() {
        return _assignee;
    }

    public void setAssignee(Identity assignee) {
        this._assignee = assignee;
    }

    @XMLProperty
    public void setCertification(String certification)
    {
        _certification = certification;
    }

    public void setCertification(Certification a)
    {
        _certification = a.getId();
    }

    public String getCertification()
    {
        return _certification;
    }

    public Certification getCertification(Resolver resolver) throws GeneralException
    {
        return (null != _certification)
            ? resolver.getObjectById(Certification.class, _certification) : null;
    }

    @XMLProperty
    public void setCertificationEntity(String id)
    {
        certificationEntity = id;
    }
    
    public void setCertificationEntity(CertificationEntity id)
    {
        certificationEntity = id.getId();
    }

    public String getCertificationEntity()
    {
        return certificationEntity;
    }

    public CertificationEntity getCertificationEntity(Resolver resolver)
        throws GeneralException
    {
        return (null != certificationEntity)
            ? resolver.getObjectById(CertificationEntity.class, certificationEntity)
            : null;
    }

    public CertificationEntity.Type getEntityType() {
        return _entityType;
    }

    public void setEntityType(CertificationEntity.Type entityType) {
        this._entityType = entityType;
    }

    @XMLProperty
    public void setCertificationItem(String item)
    {
        _certificationItem = item;
    }

    public void setCertificationItem(CertificationItem item)
    {
        _certificationItem = item.getId();
    }

    public String getCertificationItem()
    {
        return _certificationItem;
    }

    public CertificationItem getCertificationItem(Resolver resolver)
        throws GeneralException
    {
        return (null != _certificationItem)
            ? resolver.getObjectById(CertificationItem.class, _certificationItem)
            : null;
    }

    /**
     * Helper method to either set the certification item or certification
     * entity based on the type of item passed in.
     */
    public void setAbstractCertificationItem(AbstractCertificationItem item) {
        if (item instanceof CertificationEntity) {
            this.setCertificationEntity((CertificationEntity) item);
        }
        else if (item instanceof CertificationItem) {
            this.setCertificationItem((CertificationItem) item);
        }
    }
    
    @BidirectionalCollection(elementClass=RemediationItem.class, elementProperty="workItem")
    @XMLProperty(mode=SerializationMode.INLINE_LIST_UNQUALIFIED)
    public void setRemediationItems(List<RemediationItem> items) {
        _remediationItems = items;
    }

    public List<RemediationItem> getRemediationItems() {
        return _remediationItems;
    }

    //////////////////////////////////////////////////////////////////////
    //
    // Utility Methods
    //
    //////////////////////////////////////////////////////////////////////

    public void setApprovalSet(ApprovalSet aset) {
        setAttribute(ATT_APPROVAL_SET, aset);
    }
    
    public ApprovalSet getApprovalSet() {
        Object o = getAttribute(ATT_APPROVAL_SET);
        return ApprovalSet.castApprovalSet(o);
    }

    /**
     * Add signoff to the work item. WorkItems
     * will typically only contain a single signoff, but 
     * multiples can be added.
     * @param esig - Signature added to the list of signoffs. 
     * 
     * @ignore            
     * TODO: We are currently only storing a single signoff in WorkItem Attributes
     * If we need multiple, we will want to store this to a list
     * 
     */
    @Override
    public void addSignOff(SignOffHistory esig) {
        setAttribute(ATT_SIGNATURE, esig);
    }
    
    /**
     * @ignore
     * Override SailPointObject getSignoffs in order to return WorkItem signoffs
     * 
     * TODO: We are currently only storing a single signoff in WorkItem Attributes
     * If we need multiple, we will want to store this to a list
     */
    @Override
    public List<SignOffHistory> getSignOffs() {
        List<SignOffHistory> esig = new ArrayList<SignOffHistory>();
        Object o = getAttribute(ATT_SIGNATURE);
        if (o instanceof SignOffHistory)
            esig.add((SignOffHistory)o);
        return esig;
    }

    public WorkItemHandler getHandlerInstance() throws GeneralException {

        WorkItemHandler handler = null;
        if (_handler != null) {
            try {
                Class cls = Class.forName(_handler);
                handler = (WorkItemHandler)cls.newInstance();
            }
            catch (Throwable t) {
                // log this but don't let it prevent the commit
                if (log.isErrorEnabled())
                    log.error("Invalid work item handler class [" + handler + "]: " +
                              t.getMessage(), t);
            }
        }
        return handler;
    }
    
    public String getCompleter() {
        return (String) getAttribute(ATT_COMPLETER);
    }
    
    public void setCompleter(String completedBy) {
        this.put(ATT_COMPLETER, completedBy);
    }

    /**
     * Set the target class using a class object.
     * This makes it easier to remember to use the simple name, not
     * the package qualified name.
     */
    public void setTargetClass(Class cls)
    {
        if (cls != null)
            _targetClass = cls.getSimpleName();
    }

    public void setTarget(SailPointObject obj) {
        if (obj != null) {
            setTargetClass(obj.getClass());
            setTargetId(obj.getId());
            setTargetName(obj.getName());
        }
    }

    public boolean isTargetClass(String cls) {

        return (cls != null && cls.equals(_targetClass));
    }

    public boolean isTargetClass(Class cls) {

        return (cls != null && cls.getSimpleName().equals(_targetClass));
    }

    public Object getAttribute(String name)
    {
        return ((_attributes != null) ? _attributes.get(name) : null);
    }

    public void setAttribute(String name, Object value)
    {
        if (_attributes == null)
            _attributes = new Attributes<String, Object>();
        // sigh, I with Attributes did this
        if (value == null)
            _attributes.remove(name);
        else
            _attributes.put(name, value);
    }

    public Object get(String name)
    {
        return getAttribute(name);
    }

    public void put(String name, Object value)
    {
        setAttribute(name, value);
    }

    // jsl - this is such a common case, provide a special accessor
    public String getString(String name) {
        return (_attributes != null) ? _attributes.getString(name) : null;
    }

    public int getInt(String name) {
        return (_attributes != null) ? _attributes.getInt(name) : 0;
    }

    public boolean getBoolean(String name) {
        return (_attributes != null) ? _attributes.getBoolean(name) : false;
    }

    public Date getDate(String name) {
        return (_attributes != null) ? _attributes.getDate(name) : null;
    }

    public List getList(String name) {
        return (_attributes != null) ? _attributes.getList(name) : null;
    }

    public Object removeAttribute(String name) {

        return ((_attributes != null) ? _attributes.remove(name) : null);
    }

    /**
     * Add a comment with a timestamp and person that made the comment.
     * 
     * @param comment
     *            The comment to add.
     * @param commentator
     *            The person making the comment.
     */
    public void addComment(String comment, Identity commentator)
    {
        String author = (null != commentator) ? commentator.getDisplayableName() : null;
        addComment(comment, author);
    }

    public void addComment(String comment, String author)
    {
        if (null == _comments)
            _comments = new ArrayList<Comment>();
        _comments.add(new Comment(comment, author));
    }

    public void addComment(String comment)
    {
        addComment(comment, (String)null);
    }

    /**
     * Return the Form used for rendering this item.
     * A copy of this is maintained so there is no need to go back to the
     * Approval object.
     */
    public Form getForm() {
        Form form = null;
        Object o = get(ATT_FORM);
        if (o instanceof Form)
            form = (Form)o;
        return form;
    }

    public void setForm(Form f) {
        put(ATT_FORM, f);
    }

    /**
     * Return the TaskResult for the associated workflow if any.
     */
    public TaskResult getTaskResult(Resolver r) 
        throws GeneralException {

        TaskResult result = null;
        String resid = getString(ATT_TASK_RESULT);
        if (resid != null)
            result = r.getObjectById(TaskResult.class, resid);

        return result;
    }

    //////////////////////////////////////////////////////////////////////
    //
    // Notifiable implementation 
    //
    //////////////////////////////////////////////////////////////////////

    /**
     * Setup the work item expiration, reminder, and escalation information
     * (including resetting the wakeupDate and wakeupInterval) based on the
     * given notification configuration and expiration settings.
     * 
     * @param  resolver     The Resolver to use to load defaults.
     * @param  expiration   The expiration of the work item (possibly null).
     * @param  notifConfig  The notification configuration (possibly null).
     */
    public void setupNotificationConfig(Resolver resolver, Date expiration,
                                        NotificationConfig notifConfig)
        throws GeneralException {

        // Set the expiration date of the work item.
        this.setExpiration(expiration);
        this.setNotificationConfig(notifConfig);

        // Let the config calculate the wake up date for this work item.
        if (null != notifConfig) {
            notifConfig.assignWakeUpDate(this, expiration);
        }
    }

    /**
     * Return a friendly name for this item.
     */
    public String getNotificationName() {
        // Since 'name' is now the sequential ID, use the 
        // description property if it exists for work item
        // name in notification. This matches inbox.
        String name = getDescription();
        if (null == name) {
            name = getName();
        }
        return name;
    }

    /**
     * Get the number of reminders that have been sent.
     */
    public int getRemindersSent() {
        return _reminders;
    }

    /**
     * Increment the number of reminders that have been sent.
     */
    public void incrementRemindersSent() {
        _reminders++;
    }

    /**
     * Reset the number of reminders that have been sent.
     */
    public void resetRemindersSent() {
        _reminders = 0;
    }

    /**
     * Return the "owner" of this item. This is the user that should receive
     * reminders or be subject to escalation.
     */
    public Identity getNotificationOwner(Resolver resolver) {
        return getOwner();
    }

    /*
     * WorkItems do escalate on max reminders.
     */
    public boolean isEscalateOnMaxReminders() {
        return true;
    }

    /**
     * Save the given escalation error on this item.
     */
    @SuppressWarnings("unchecked")
    public void saveEscalationError(InvalidEscalationTargetException error) {
        List<InvalidEscalationTargetException> escalationErrorList =
            (List<InvalidEscalationTargetException>) getAttribute(WorkItemManagerAttributes.EscalationErrors.toString());
        
        if (escalationErrorList == null) {
            escalationErrorList = new ArrayList<InvalidEscalationTargetException>();
        }
        
        escalationErrorList.add(error);
        setAttribute(WorkItemManagerAttributes.EscalationErrors.toString(), escalationErrorList);

    }

    /**
     * Return whether this item supports expiration or not.
     */
    public boolean isExpirable() {
        return true;
    }

    /**
     * Return true if this item is expired according to the current time and
     * the expiration date for this item.
     */
    public boolean isExpired() {
        return (null != _expiration) && Util.isDateAfter(_wakeUpDate, _expiration);
    }

    /**
     * Return the expiration date for this item.
     */
    public Date getExpirationDate() {
        return getExpiration();
    }
    
    /**
     * Copy the notification config and state from the given WorkItem into this
     * WorkItem.
     * 
     * @param  item  The WorkItem from which to copy the lifecyle information.
     */
    public void copyLifecycleInfo(WorkItem item) {

        setWakeUpDate(item.getWakeUpDate());
        setExpiration(item.getExpiration());
        setNotificationConfig(item.getNotificationConfig());
    }

    /**
     * Return whether this WorkItem already has a notification config and
     * lifecycle state set on it.
     */
    public boolean hasLifecycleInfo() {
        return (null != _wakeUpDate) || (null != _expiration) ||
               (null != _notificationConfig);
    }
    
    @XMLProperty
    public String getIdentityRequestId() {
        return _identityRequestId;
    }
    
    public void setIdentityRequestId(String id) {
        _identityRequestId = id;
    }
    

    //////////////////////////////////////////////////////////////////////
    //
    // Certifications
    //
    //////////////////////////////////////////////////////////////////////

    /**
     * Add a remediation item to this work item. This will change the
     * description and clear the comments if this work item previously held a
     * single remediation item but now is handling multiple remediation
     * requests. This also clears the notification date on this WorkItem so a
     * notification will be sent again with the new information.
     * 
     * @param  cert        The Certification the item came from.
     * @param  certItemId  The ID of the CertificationItem.
     * @param  identity    The name of the Identity being remediated.
     * @param  entityType  The type of item being remediated
     * @param  action      The CertificationAction with the remediation info.
     * @param  plan        Remediation details                    
     * 
     * @return A RemediationItem that is already on this WorkItem that matches
     *         the RemediationItem being added. This will be removed from the
     *         WorkItem and replaced. The calling code should delete the
     *         returned remediation item.
     */
    public RemediationItem addRemediationItem(Certification cert, String certItemId,
                                              String identity,
                                              RemediationItem.RemediationEntityType entityType,
                                              CertificationAction action, ProvisioningPlan plan,
                                              List<PolicyTreeNode> contributingEntitlements) {

        RemediationItem removed = null;
        
        if (null == _remediationItems) {
            _remediationItems = new ArrayList<RemediationItem>();
        }

        // If there is a remediation item for this certification item already,
        // remove it.  This can happen if a remediation work item is not closed,
        // a continuous cert item transitions to the "certification required"
        // state, and the item is remediated again.
        for (RemediationItem current : _remediationItems) {
            if (certItemId.equals(current.getCertificationItem()) || revokeAccountRequestsMatch(current, action)) {
                removed = current;
                _remediationItems.remove(current);
                break;
            }
        }
        
        RemediationItem ri = new RemediationItem(certItemId, entityType, identity, action, plan);
        if (!Util.isEmpty(contributingEntitlements)) {
            //Need to set these on the Remediation Item
            ri.setAttribute(RemediationItem.ARG_CONTRIBUTING_ENTS, contributingEntitlements);
        }
        _remediationItems.add(ri);
        ri.setWorkItem(this);

        // Clear the notification date on this work item.  New information has
        // been added to this work item, so we want to re-send it.
        _notification = null;
        
        // If this work item now has multiple remediation items, change the
        // description and clear the comments.  They are specific to the first
        // remediation item that was added.
        if (2 == _remediationItems.size() && !action.isRevokeAccount()) {
            String fullname = getOwner().getDisplayableName();
            Message desc = new Message(MessageKeys.DESC_MULT_REMED_WITH_CERT, cert.getShortName(), fullname);
            this.setDescription(desc.getLocalizedMessage());

            // Consider removing this if we're going to allow adding remediation
            // items after the initial work item creation process is complete.
            _comments.clear();

            // Clear the certification item.
            _certificationItem= null;
        } else if (2 == _remediationItems.size() && action.isRevokeAccount()) {
            String combinedAccountRevocations = null;
            for (RemediationItem current : _remediationItems) {
                String description = current.getDescription();
                if (combinedAccountRevocations  == null) {
                    combinedAccountRevocations = description;
                } else if (description != null){
                    combinedAccountRevocations = combinedAccountRevocations + ", " + description;
                }
            }
            this.setDescription(combinedAccountRevocations);
        }

        return removed;
    }
    
    private boolean revokeAccountRequestsMatch(RemediationItem current, CertificationAction action) {
        boolean allMatch = false;
        List<AccountRequest> currentRequests = current.getRemediationDetails() != null ? current.getRemediationDetails().getAccountRequests() : null;
        List<AccountRequest> actionRequests = action.getRemediationDetails() != null ? action.getRemediationDetails().getAccountRequests() : null;
        if(action.isRevokeAccount()) {
            for (AccountRequest currentAR : Util.iterate(currentRequests)) {
                boolean foundCurrentMatch = false;
                for (AccountRequest actionAR : Util.iterate(actionRequests)) {
                    if (Util.nullSafeCaseInsensitiveEq(currentAR.getNativeIdentity(), actionAR.getNativeIdentity())
                            && Util.nullSafeCaseInsensitiveEq(currentAR.getApplication(), actionAR.getApplication())) {
                        foundCurrentMatch = true;
                    }
                }
                allMatch = foundCurrentMatch;
            }
        }
        return allMatch;
    }

    public void addRemediationItem(Identity actor, RemediationItem.RemediationEntityType remediationType, String remediationIdentity,
                                   ProvisioningPlan plan, String description,
                                   String comments, List<PolicyTreeNode> contributingEntitlements) {

        if (null == _remediationItems) {
            _remediationItems = new ArrayList<RemediationItem>();
        }
        RemediationItem ri = new RemediationItem(actor, remediationIdentity, remediationType, plan,
                               description, comments);

        if (!Util.isEmpty(contributingEntitlements)) {
            //Need to set these on the Remediation Item
            ri.setAttribute(RemediationItem.ARG_CONTRIBUTING_ENTS, contributingEntitlements);
        }
        _remediationItems.add(ri);
        ri.setWorkItem(this);

        // If this work item now has multiple remediation items, change the
        // description and clear the comments.  They are specific to the first
        // remediation item that was added.
        if (2 == _remediationItems.size()) {
            String fullname =
                Util.getFullname(getOwner().getFirstname(), getOwner().getLastname());
            Message desc = new Message(MessageKeys.DESC_MULT_REMED_WITHOUT_CERT, fullname);
            this.setDescription(desc.getLocalizedMessage());

            // Consider removing this if we're going to allow adding remediation
            // items after the initial work item creation process is complete.
            _comments.clear();

            // Clear the certification item.
            _certificationItem= null;
        }
    }

    /**
     * Return true if this work item is certification-related in some way.
     */
    public boolean isCertificationRelated() {
        // Currently allow certification-related work items (certification,
        // delegation, remediation, and challenge) have a certification ID.
        return (null != _certification);
    }


    //////////////////////////////////////////////////////////////////////
    //
    // Object overrides
    //
    //////////////////////////////////////////////////////////////////////

    public String toString()
    {
        StringBuffer buf = new StringBuffer("[WorkItem: [name = ");
        buf.append(_name);
        buf.append("], [type = ");
        buf.append(_type);
        buf.append("], [state = ");
        buf.append(_state);
        buf.append("], [level = ");
        buf.append(_level);
        buf.append("], [requester = ");

        if (_requester != null)
        {
            buf.append(_requester.getName());
        }

        buf.append("], [comments = ");

        if (_comments != null)
        {
            buf.append(_comments.toString());
        }

        buf.append("], [completionComments = ");
        buf.append(_completionComments);
        buf.append("], [notification = ");
        if (_notification != null)
        {
            buf.append(_notification.toString());
        }
        buf.append("], [expiration = ");
        if (_expiration != null)
        {
            buf.append(_expiration.toString());
        }

        buf.append("], [wakeUpDate = ");

        if (_wakeUpDate != null)
        {
            buf.append(_wakeUpDate.toString());
        }

        buf.append("], [notificationConfig = ");
        buf.append(_notificationConfig);
        buf.append("], [reminders = ");
        buf.append(_reminders);
        buf.append("]]");
        return buf.toString();
    }

}
