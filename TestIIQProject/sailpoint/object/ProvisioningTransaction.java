/* (c) Copyright 2016 SailPoint Technologies, Inc., All Rights Reserved. */

package sailpoint.object;

import java.io.Serializable;
import java.util.LinkedHashMap;
import java.util.Locale;
import java.util.Map;
import java.util.TimeZone;

import sailpoint.tools.Localizable;
import sailpoint.tools.Message;
import sailpoint.tools.xml.SerializationMode;
import sailpoint.tools.xml.XMLClass;
import sailpoint.tools.xml.XMLProperty;
import sailpoint.web.messages.MessageKeys;

/**
 * This object that will be used to persist data to be used by the
 * Provisioning Transaction Monitoring UI. Contains all the necessary information to represent
 * the UI.
 * 
 * @author brian.li
 *
 */
@XMLClass
public class ProvisioningTransaction extends SailPointObject {
    
    private static final long serialVersionUID = -430019586298309004L;

    /**
     * Constant used to store the account/object request from the attributes.
     */
    public static final String ATT_REQUEST = "request";

    /**
     * Constant used to store the plan result from the attributes.
     */
    public static final String ATT_PLAN_RESULT = "planResult";

    /**
     * Constant used to store the id of the retry Request object.
     */
    public static final String ATT_RETRY_REQUEST_ID = "retryRequestId";

    /**
     * Constant used to store the id of the wait work item that is used
     * to trigger a workflow retry.
     */
    public static final String ATT_WAIT_WORK_ITEM_ID = "waitWorkItemId";

    /**
     * Constant used to store the retry count.
     */
    public static final String ATT_RETRY_COUNT = "retryCount";

    /**
     * Constant used to store the last time the transaction was retried.
     */
    public static final String ATT_LAST_RETRY = "lastRetry";

    /**
     * Constant used to store a flag that indicates the transaction
     * failed because of retry time out.
     */
    public static final String ATT_TIMED_OUT = "timedOut";

    /**
     * Constant used to store any ticket id that was generated by
     * this provisioning transaction.
     */
    public static final String ATT_TICKET_ID = "ticketId";

    /**
     * Constant used to store the name of the manual work item created
     * when a transaction is forced.
     */
    public static final String ATT_MANUAL_WORK_ITEM = "manualWorkItem";

    /**
     * Constant used to store any filtered items.
     */
    public static final String ATT_FILTERED = "filtered";

    /**
     * Constant used to store the certification name if applicable.
     */
    public static final String ATT_CERT_NAME = "certificationName";

    /**
     * Constant used to store the access request id if applicable.
     */
    public static final String ATT_ACCESS_REQUEST_ID = "accessRequestId";

    /**
     * Constant used for the value of the integration property when the
     * provisioning occurred through a manual work item.
     */
    public static final String MANUAL_INTEGRATION = "Work Item";

    /**
     * String representation of the enumeration of what type of operation is occuring
     * These may be from {@link sailpoint.object.ProvisioningPlan.AccountRequest.Operation}
     * or {@link sailpoint.object.ProvisioningPlan.Operation}
     */
    private String operation;
    
    /**
     * String representation of the {@link sailpoint.object.Source} enumerations.
     * Used to show the origin of the transaction, null to be used for custom code
     */
    private String source;
    private String applicationName;
    private String identityName;
    private String identityDisplayName;
    private String nativeIdentity;
    private String accountDisplayName;
    
    /**
     * Status of the current ProvisionTransaction. 
     * Pending will be initiated when a user starts the manual retry process
     */
    private Status status;
    /**
     * Whether or not the type of transaction is a manually kicked off or not.
     */
    private Type type;
    
    private Attributes<String, Object> attributes;

    /**
     * The target integration the transaction was provisioned through.
     */
    private String integration;

    /**
     * Determines if the transaction was manually forced by a user.
     */
    private boolean forced;

    /**
     * The id of the certification the transaction is associated with. Only
     * relevant if the source is Certification.
     */
    private String certificationId;

    @Override
    public boolean hasAssignedScope() {
        return false;
    }

    @XMLClass(xmlname="ProvisioningTransactionType")
    public enum Type implements Localizable, Serializable {
        Manual(MessageKeys.PROVISIONING_TRANSACTION_TYPE_MANUAL),
        Auto(MessageKeys.PROVISIONING_TRANSACTION_TYPE_AUTO);

        private String messageKey;
        
        private Type(String messageKey) {
            this.messageKey = messageKey;
        }

        @Override
        public String getLocalizedMessage() {
            return getLocalizedMessage(Locale.getDefault(), TimeZone.getDefault());
        }
        @Override
        public String getLocalizedMessage(Locale locale, TimeZone timezone) {
            Message msg = new Message(this.messageKey);
            return msg.getLocalizedMessage(locale, timezone);
        }
    };
    
    @XMLClass(xmlname="ProvisioningTransactionStatus")
    public enum Status implements Localizable, Serializable {
        /**
         * The provisioning transaction has successfully completed
         */
        Success(MessageKeys.PROVISIONING_TRANSACTION_STATUS_SUCCESS),

        /**
         * When a manual retry is initiated, the Pending status is used.
         * Retries can happen when the connector returns a Retry status in the ProvisioningResult
         */
        Pending(MessageKeys.PROVISIONING_TRANSACTION_STATUS_PENDING),

        /**
         * The provisioning transaction has failed.  
         */
        Failed(MessageKeys.PROVISIONING_TRANSACTION_STATUS_FAILED);

        private String messageKey;
        
        private Status(String messageKey) {
            this.messageKey = messageKey;
        }

        @Override
        public String getLocalizedMessage() {
            return getLocalizedMessage(Locale.getDefault(), TimeZone.getDefault());
        }
        @Override
        public String getLocalizedMessage(Locale locale, TimeZone timezone) {
            Message msg = new Message(this.messageKey);
            return msg.getLocalizedMessage(locale, timezone);
        }
    };
    
    /**
     * The configurable logging level for users to see levels of messages.
     * Configured levels act like log4j, where a selected level will also show the level below
     * Can be configured in the system configuration, refresh task, and certification pages.
     * 
     * Ex. If a sysadmin selects Retry, it also implies seeing Failure messages.
     *
     */
    @XMLClass(xmlname="ProvisioningTransactionLevel")
    public enum Level implements Localizable, Serializable {
        /**
         * Logging level to display Successful messages and below
         */
        Success(MessageKeys.PROVISIONING_TRANSACTION_LEVEL_SUCCESS),
        /**
         * Logging level to display Retry messages and below
         */
        Retry(MessageKeys.PROVISIONING_TRANSACTION_LEVEL_RETRY),
        /**
         * Logging level to display Failure messages only
         */
        Failure(MessageKeys.PROVISIONING_TRANSACTION_LEVEL_FAILURE);
        
        private String messageKey;
        
        private Level(String messageKey) {
            this.messageKey = messageKey;
        }

        @Override
        public String getLocalizedMessage() {
            return getLocalizedMessage(Locale.getDefault(), TimeZone.getDefault());
        }

        @Override
        public String getLocalizedMessage(Locale locale, TimeZone timezone) {
            Message msg = new Message(this.messageKey);
            return msg.getLocalizedMessage(locale, timezone);
        }
    }

    @XMLProperty
    public String getOperation() {
        return operation;
    }

    public void setOperation(String operation) {
        this.operation = operation;
    }

    @XMLProperty(mode=SerializationMode.UNQUALIFIED)
    public Attributes<String, Object> getAttributes() {
        return attributes;
    }

    public void setAttributes(Attributes<String, Object> attributes) {
        this.attributes = attributes;
    }

    @XMLProperty
    public String getSource() {
        return source;
    }

    public void setSource(String source) {
        this.source = source;
    }
    
    public void setSource(Source source) {
        this.source = source.toString();
    }

    @XMLProperty
    public String getApplicationName() {
        return applicationName;
    }

    public void setApplicationName(String applicationName) {
        this.applicationName = applicationName;
    }

    @XMLProperty
    public String getIdentityName() {
        return identityName;
    }

    public void setIdentityName(String identityName) {
        this.identityName = identityName;
    }

    @XMLProperty
    public String getIdentityDisplayName() {
        return identityDisplayName;
    }

    public void setIdentityDisplayName(String identityDisplayName) {
        this.identityDisplayName = identityDisplayName;
    }

    @XMLProperty
    public String getNativeIdentity() {
        return nativeIdentity;
    }

    public void setNativeIdentity(String nativeIdentity) {
        this.nativeIdentity = nativeIdentity;
    }

    @XMLProperty
    public String getAccountDisplayName() {
        return accountDisplayName;
    }

    public void setAccountDisplayName(String accountDisplayName) {
        this.accountDisplayName = accountDisplayName;
    }

    @XMLProperty
    public Type getType() {
        return type;
    }

    public void setType(Type type) {
        this.type = type;
    }

    @XMLProperty
    public Status getStatus() {
        return status;
    }

    public void setStatus(Status status) {
        this.status = status;
    }

    /**
     * Gets the integration name.
     *
     * @return The integration name.
     */
    @XMLProperty
    public String getIntegration() {
        return integration;
    }

    /**
     * Sets the integration name.
     *
     * @param integration The integration name.
     */
    public void setIntegration(String integration) {
        this.integration = integration;
    }

    /**
     * Determines if the transaction was manually
     * forced by a user.
     *
     * @return True if forced, false otherwise.
     */
    @XMLProperty
    public boolean isForced() {
        return forced;
    }

    /**
     * Sets whether or not the transaction was manually
     * forced by a user.
     *
     * @param forced True if forced, false otherwise.
     */
    public void setForced(boolean forced) {
        this.forced = forced;
    }

    /**
     * Gets the id of the certification that the transaction is
     * associated with if any.
     *
     * @return The certification id or null.
     */
    @XMLProperty
    public String getCertificationId() {
        return certificationId;
    }

    /**
     * Sets the id of the certification that the transaction is
     * associated with.
     *
     * @param certificationId The certification id.
     */
    public void setCertificationId(String certificationId) {
        this.certificationId = certificationId;
    }

    /**
     * Gets the columns that will be printed in the console.
     *
     * @return The columns.
     */
    public static Map<String, String> getDisplayColumns() {
        Map<String, String> columns = new LinkedHashMap<String, String>();
        columns.put("id", "Id");
        columns.put("status", "Status");
        columns.put("source", "Source");
        columns.put("identityName", "Identity");
        columns.put("applicationName", "Application");

        return columns;
    }

    /**
     * Gets the format string for the columns displayed in the console.
     *
     * @return The format string.
     */
    public static String getDisplayFormat() {
        return "%-34s %-16s %-16s %-32s %s\n";
    }

}
