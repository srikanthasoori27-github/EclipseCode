/* (c) Copyright 2008 SailPoint Technologies, Inc., All Rights Reserved. */

package sailpoint.object;

import java.util.ArrayList;
import java.util.Date;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.Set;
import java.util.TimeZone;

import sailpoint.api.ObjectUtil;
import sailpoint.api.SailPointContext;
import sailpoint.object.ApprovalItem.ProvisioningState;
import sailpoint.object.IdentityRequestItem.CompilationStatus;
import sailpoint.object.ProvisioningPlan.AccountRequest.Operation;
import sailpoint.object.ProvisioningPlan.AttributeRequest;
import sailpoint.object.WorkflowSummary.ApprovalSummary;
import sailpoint.provisioning.AssignmentExpander;
import sailpoint.service.ApprovalItemsService;
import sailpoint.service.IdentityResetService;
import sailpoint.service.RequestAccessService;
import sailpoint.tools.GeneralException;
import sailpoint.tools.Index;
import sailpoint.tools.Indexes;
import sailpoint.tools.Message;
import sailpoint.tools.MessageKeyHolder;
import sailpoint.tools.Util;
import sailpoint.tools.xml.SerializationMode;
import sailpoint.tools.xml.XMLClass;
import sailpoint.tools.xml.XMLProperty;
import sailpoint.tools.xml.XMLReferenceResolver;
import sailpoint.web.RegistrationBean;
import sailpoint.web.messages.MessageKeys;

/**
 * @author <a href="mailto:dan.smith@sailpoint.com">Dan Smith</a>
 *
 * Object that holds information about a provisioning request. 
 * This model is used to represent the requests while in flight 
 * and after the request completes for historical purposes.
 * The model here is typically created/updated by the workflow 
 * driving the request.
 *  
 * This has a collection of RequestItem objects that look a lot like 
 * approval Items but are persisted in a flattened db structure
 * so they can be queried. The IdentityRequestItems object holds the 
 * individual changes requested.
 * 
 * It would have been nice to use ApprovalItem here to represent the
 * request Items but because of the object relationship it was really only 
 * possible to create a new class that duplicates many of the 
 * same concepts.
 * 
 * Reason being is that ApprovalItem defines methods for owner returning
 * a String ( String get/setOwner() ), which conflicts with 
 * SailPointObject.getOwner.  
 * 
 * Since approval items are generated and used in scripts for workflows 
 * it was not possible to just rename the method without upgrade 
 * issues.
 * 
 * Notice that there is some data stored off in the attributes map while
 * other fields in columns and are search-able.
 * 
 * Each request is assigned a unique, sequential number that is stored
 * in the name field. It is not stored in the ID field which is where
 * we keep a unique ID used and generated by Hibernate.
 * 
 */
@XMLClass
@Indexes({ @Index(name="spt_idrequest_created", property="created") })
public class IdentityRequest extends SailPointObject {
    
    /**
     * The CompletionStatus of the request. This indicates
     * what the status of the request was after completion.
     *
     * @author dan.smith     
     */
    @XMLClass(xmlname="RequestCompletionStatus")
    public enum CompletionStatus implements MessageKeyHolder {
        /**
         * Success indicates all of the requested items 
         * have been completed.
         */
        Success(MessageKeys.IDENTITY_REQUEST_COMP_SUCCESS),
        
        /**
         * All of of the requested items have failed
         * to complete.
         */
        Failure(MessageKeys.IDENTITY_REQUEST_COMP_FAILURE),
        
        /**
         * One or more of the requested items failed
         * to complete, but there were one or more 
         * successes.
         */
        Incomplete(MessageKeys.IDENTITY_REQUEST_COMP_INCOMPLETE),
            
        /**
         * One or more of the requested items is still
         * pending and the completion status can not
         * yet be calculated
         */
        Pending(MessageKeys.IDENTITY_REQUEST_COMP_PENDING);
        
        private String messageKey;

        private CompletionStatus(String messageKey){
            this.messageKey = messageKey;
        }

        public String getMessageKey(){
            return messageKey;
        }
    }
    
    /**
     * An enumeration to describe the current execution state
     * of the request.
     * 
     */
    @XMLClass
    public enum ExecutionStatus implements MessageKeyHolder {
        /**
         * The request is executing, which indicates  
         * the workflow is doing some processing.
         */
        Executing(MessageKeys.IDENTITY_REQUEST_EXECUTING),
        
        /**
         * The request has finished the workflow and 
         * is waiting to be verified by the Provisioning
         * Scanner.
         */
        Verifying(MessageKeys.IDENTITY_REQUEST_VERIFYING),
        
        /**
         * The request has been terminated before it was
         * able to complete.
         */
        Terminated(MessageKeys.IDENTITY_REQUEST_TERMINATED),
        
        /**
         * The request completed and was verified.
         */
        Completed(MessageKeys.IDENTITY_REQUEST_COMPLETED);
        
        private String messageKey;

        private ExecutionStatus(String messageKey){
            this.messageKey = messageKey;
        }

        public String getMessageKey(){
            return messageKey;
        }
    }

    public static Map<String, String> typeConversionMap = new HashMap<String, String>();
    public static final String ROLES_REQUEST_FLOW_CONFIG_NAME = "RolesRequest";
    public static final String ENTITLEMENTS_REQUEST_FLOW_CONFIG_NAME = "EntitlementsRequest";
    public static final String ACCOUNTS_REQUEST_FLOW_CONFIG_NAME = IdentityResetService.Consts.Flows.ACCOUNTS_REQUEST_FLOW.value();
    public static final String EXPIRED_PASSWORD_FLOW = IdentityResetService.Consts.Flows.EXPIRED_PASSWORD_FLOW.value();
    public static final String FORGOT_PASSWORD_FLOW = IdentityResetService.Consts.Flows.FORGOT_PASSWORD_FLOW.value();
    public static final String PASSWORD_REQUEST_FLOW = IdentityResetService.Consts.Flows.PASSWORDS_REQUEST_FLOW.value();
    public static final String IDENTITY_CREATE_FLOW_CONFIG_NAME = "IdentityCreateRequest";
    public static final String IDENTITY_UPDATE_FLOW_CONFIG_NAME = "IdentityEditRequest";
    public static final String ATT_FLOW_NAME = "lcmFlowName";
    public static final String ATT_ALLOW_BULK = "lcmRequestPopulationAllowBulk";

    static {
        typeConversionMap.put(RequestAccessService.FLOW_CONFIG_NAME, MessageKeys.QUICKLINK_REQUEST_ACCESS);
        typeConversionMap.put(ROLES_REQUEST_FLOW_CONFIG_NAME, MessageKeys.QUICKLINK_REQUEST_ROLES);
        typeConversionMap.put(ENTITLEMENTS_REQUEST_FLOW_CONFIG_NAME, MessageKeys.QUICKLINK_REQUEST_ENTITLEMENTS);
        typeConversionMap.put(ACCOUNTS_REQUEST_FLOW_CONFIG_NAME, MessageKeys.QUICKLINK_MANAGE_ACCOUNTS);
        typeConversionMap.put(PASSWORD_REQUEST_FLOW, MessageKeys.QUICKLINK_MANAGE_PASSWORDS);
        typeConversionMap.put(FORGOT_PASSWORD_FLOW, MessageKeys.QUICKLINK_FORGOT_PASSWORD);
        typeConversionMap.put(EXPIRED_PASSWORD_FLOW, MessageKeys.QUICKLINK_EXPIRED_PASSWORD);
        typeConversionMap.put(IDENTITY_CREATE_FLOW_CONFIG_NAME, MessageKeys.QUICKLINK_CREATE_IDENTITY);
        typeConversionMap.put(IDENTITY_UPDATE_FLOW_CONFIG_NAME, MessageKeys.QUICKLINK_EDIT_IDENTITY);
        typeConversionMap.put(RegistrationBean.FLOW_CONFIG_NAME, MessageKeys.QUICKLINK_SELF_SERVICE_REGISTRATION);
        typeConversionMap.put(Source.PAM.name(), MessageKeys.UI_PAM_CONTAINER_LIST);
    }
    
    //////////////////////////////////////////////////////////////////////
    //
    // Fields
    //
    //////////////////////////////////////////////////////////////////////

    private static final long serialVersionUID = 1L;

    /**
     * Priority of the request, typically set by the caller when 
     * as a workflow input. Typically approvals and other work items
     * spawned as part of a request re-use this priority.
     *
     * @ignore 
     * If we decide to make WorkItem.Level more customizable we need
     * to allow that here...
     */
    WorkItem.Level _priority;

    /**
     * Current state of the request, configured as the request
     * states through its lifecycle. Typically this is set
     * to the top level step name currently being visited. Things
     * like Init, Approve, Provision, Notify, Finalize and end. 
     *
     * Leaving this a string so it can be set to any value.
     */
    String _state;

    /**
     * This is the type of request, in LCM this is based on
     * the flow that that originated this request.

     */
    String _type;

    /**
     * The displayName of the identity that made the request.
     * We keep displayName here so we can sort on grids
     * and search on displayName. Also keeping the ID around
     * to help when identities are renamed.
     */
    String _requesterDisplayName;

    /**
     * The id of the Identity that made the request. 
     * This property might have an id that is no
     * longer valid (due to delete) so callers must be aware
     * and handle cases where this Identity might no longer exist.
     */
    String _requesterId;

    /**
     * The target of the request, this is typically the name
     * and id of the identity that is to be created/updated.
     */
    String _targetId;

    /**
     * Using displayName instead of name here so it can sort/display
     * in ui tier.
     */
    String _targetDisplayName;

    /**
     * @ignore
     * Here as a placeholder, might just assume the class
     * is always Identity?
     */
    String _targetClass;

    /**
     * Completion date of the request.
     */ 
    Date _endDate;
    
    /**
     * Completion status of the request, which
     * is set after the request has completed. 
     * This status indicates Success, Failure
     * or Incomplete. 
     */
    CompletionStatus _completionStatus;  
    
    /**
     * Execution status of the request.
     * This indicates things like Executing, Verifying,
     * Terminated and Completed.
     */
    ExecutionStatus _executionStatus;
    
    /**
     * Flag to indicate there are one or more
     * messages or errors in the request's attribute
     * Map.
     */
    boolean _hasMessages;
    
    /**
     * Date the entire request has been verified by the provisioning scanner. 
     * Null indicates it has not been verified.
     */
    Date _verified;

    /**
     * The items for the request, this list includes
     * things that were requested AND expanded during
     * compilation.
     */
    List<IdentityRequestItem> _items;

    /**
     * String version of sailpoint.object.Source where the request originated.
     * Think of this like "interface" where the request came from LCM, UI,
     * WEB_SERVICE, etc.
     */
    String _source;
    
    /**
     * Optional external ticket ID that can be adorned to the request when integrating
     * with ticketing systems. This is a searchable column that is set during the workflow
     * typically after a ticket is created.
     */
    String _externalTicketId;
    
    /**
     * Bag of xml based attributes that holds the non-queryable properties.
     * 
     * 
     * Normally holds at least the following keys:
     *
     *   approvalSummaries: List of approval summaries accumulated as the workflow executes
     *   finalProject: Project finally pushed out to the integration executors. 
     *   errors: Project finally pushed out to the integration executors. 
     *   warnings: Project finally pushed out to the integration executors. 
     */
    Attributes<String,Object> _attributes;

    /**
     * Flag to indicate if this was part of a bulk request.
     */
    public static final String ATT_BULK_REQUEST = "isBulkRequest";
    
    /**
     * The id of the workflow case's task result. This
     * must be here so an in flight request can be terminated.
     * Additionally it helps when upgrading
     * existing task results.
     */
    public static final String ATT_TASK_RESULT_ID = "taskResultId";

    /**
     * A boolean indiciating that granular role expansion items were
     * suppressed and should not be refreshed later phases.
     */
    public static final String ATT_SUPPRESSED_EXPANSION_ITEMS = "suppressedExpansionItems";
    
    /**
     * List of errors and warnings that are adorned from the 
     * task result or the ProvisioningPlan.
     */
    public static final String ATT_MESSAGES  = "messages";

    /**
     * List of Interactions kept by the workflow as it
     * visits Approval steps.
     */
    public static final String ATT_APPROVAL_SUMMARIES = "approvalSummaries";
    
    /**
     * The project provisioned, which is set when the request is 
     * completed.  
     * 
     */
    public static final String ATT_PROVISIONED_PROJECT = "provisionedProject";
    
    /**
     * List of Maps produced during the workflow that summarize the violations.
     * 
     * Each Map in the list will contain the following keys: 
     * 
     *    - constraintDescription - PolicyViolation's constraint's description
     *    - policyType - Policy type
     *    - policyName - Policy Violation policy name
     *    - ruleName - Policy Violation constraint name
     *    - description - Policy Violation Description
     *    - right and left Bundles ( rightBundle and leftBundle ) : when ROLE SOD
     */
    public static final String ATT_POLICY_VIOLATION_MAPS = "policyViolationMaps";

    /**
     * Date the request was canceled. It would be nice to just set endDate instead of this, but I
     * am worried that other places might assume endDate means "completed", and we do not have a
     * CompletionStatus of Terminated for IdentityRequests. Maybe we should?
     */
    public static final String ATT_TERMINATED_DATE = "terminatedDate";

    //////////////////////////////////////////////////////////////////////
    //
    // Constructors
    //
    //////////////////////////////////////////////////////////////////////

    public IdentityRequest() {
    }

    //////////////////////////////////////////////////////////////////////
    //
    // Properties
    //
    //////////////////////////////////////////////////////////////////////
    
    @XMLProperty
    public WorkItem.Level getPriority() {
        return _priority;
    }

    public void setPriority(WorkItem.Level priority) {
        _priority = priority;
    }

    @XMLProperty
    public String getRequesterDisplayName() {
        return _requesterDisplayName;
    }

    public void setRequesterDisplayName(String requesterDisplayName) {
        _requesterDisplayName = requesterDisplayName;
    }

    @XMLProperty
    public String getRequesterId() {
        return _requesterId;
    }

    public void setRequesterId(String requesterId) {
        _requesterId = requesterId;
    }

    @XMLProperty
    public String getTargetId() {
        return _targetId;
    }

    public void setTargetId(String targetId) {
        _targetId = targetId;
    }

    @XMLProperty
    public String getTargetDisplayName() {
        return _targetDisplayName;
    }

    public void setTargetDisplayName(String targetDisplayName) {
        _targetDisplayName = targetDisplayName;
    }

    @XMLProperty
    public String getTargetClass() {
        return _targetClass;
    }

    public void setTargetClass(String targetClass) {
        _targetClass = targetClass;
    }

    @XMLProperty
    public String getState() {
        return _state;
    }

    public void setState(String state) {
        _state = state;
    }
    
    ///////////////////////////////////////////////////////////////////////////
    //
    // RequestItem Handling
    //
    ///////////////////////////////////////////////////////////////////////////

    @XMLProperty(xmlname="RequestItems")
    public List<IdentityRequestItem> getItems() {
        return _items;
    }

    public void setItems(List<IdentityRequestItem> items) {
        _items = items;
    }
    
    /**
     * Returns all of the items that have been verified and 
     * marked ProvisioningComplete.
     * 
     * @return items list of identity requests null if none are complete.
     */
    public List<IdentityRequestItem> getProvisioningCompleteItems() {
        List<IdentityRequestItem> items = new ArrayList<IdentityRequestItem>();
        if ( Util.size(_items) > 0 )  {
            for ( IdentityRequestItem item : _items ) {
                if ( item != null  && item.isProvisioningComplete() ) {
                    items.add(item);
                }
            }
        }
        return ( Util.size(items) > 0 ) ? items : null;
    }
    
    public List<IdentityRequestItem> getProvisioningFailedItems() {
        List<IdentityRequestItem> items = new ArrayList<IdentityRequestItem>();
        if ( Util.size(_items) > 0 )  {
            for ( IdentityRequestItem item : _items ) {            
                if ( item != null  && item.isProvisioningFailed() ) {
                    items.add(item);
                }                
            }
        }
        return ( Util.size(items) > 0 ) ? items : null;
    }
    
    public List<IdentityRequestItem> getApprovalCompleteItems() {
        List<IdentityRequestItem> items = new ArrayList<IdentityRequestItem>();
        if ( Util.size(_items) > 0 )  {
            for ( IdentityRequestItem item : _items ) {
                if ( item != null && item.isApprovalComplete() ) {
                    items.add(item);
                }
            }
        }
        return ( Util.size(items) > 0 ) ? items : null;    
    }
    
    public List<IdentityRequestItem> getProvisioningPendingItems() {
        List<IdentityRequestItem> items = new ArrayList<IdentityRequestItem>();
        if ( Util.size(_items) > 0 )  {
            for ( IdentityRequestItem item : _items ) {
                if ( item == null ) continue;

                if ( ( item.getProvisioningState() == null ) ||
                     ( Util.nullSafeEq(item.getProvisioningState(), ProvisioningState.Commited) ) ||
                     ( Util.nullSafeEq(item.getProvisioningState(), ProvisioningState.Pending) ) )  {
                    items.add(item);
                }
            }
        }
        return ( Util.size(items) > 0 ) ? items : null;    
    }

    public List<IdentityRequestItem> getProvisioningRetryItems() {
        List<IdentityRequestItem> retryItems = new ArrayList<IdentityRequestItem>();
        if ( Util.size(_items) > 0 )  {
            for ( IdentityRequestItem item : _items ) {
                if ( item == null ) continue;

                if (Util.nullSafeEq(item.getProvisioningState(), ProvisioningState.Retry)) {
                    retryItems.add(item);
                }
            }
        }
        return retryItems;
    }
    
    /**
     * 
     * Add a new non-null item to the request and mark it as
     * an expansion if it is found in the project's 
     * expansion list.
     * 
     * @param item IdentityRequestItem to add as expansion
     * @param project ProvisioningProject to search for matching expansion item
     */
    public void addExpansion(IdentityRequestItem item,
                             ProvisioningProject project) {
        if ( item != null ) {
            // Try to find more expansion info if we have the project.
            if (null != project) {
                ExpansionItem expansion =
                    project.getExpansionItem(item.getApplication(),
                                             item.getInstance(),
                                             item.getNativeIdentity(),
                                             item.getName(),
                                             item.getValue()); 
                if (null != expansion) {
                    item.setExpansionCause(expansion.getCause());
                    item.setExpansionInfo(expansion.getSourceInfo());                    

                }
            }
            item.setCompilationStatus(CompilationStatus.Expansion);
            // mark this approved ( implicitly approved )
            item.setApprovalState(WorkItem.State.Finished);
            // who is the owner? should this be set?
            add(item);
        }
    }
    
    /**
     * Add an new non-null item to a Request.
     * @param item IdentityRequestItem to add
     */
    public void add(IdentityRequestItem item) {
        if ( item != null ) {
            List<IdentityRequestItem> items = getItems();
            if ( items == null ) {
                items = new ArrayList<IdentityRequestItem>();
                setItems(items);
            }
            items.add(item);
            // for inverse relationsjip
            item.setIdentityRequest(this);
        }
    }
    
    /**
     * Find any items matching application, nativeIdentity, instance, attribute,
     * operation and assignmentId.
     * 
     * If attrName or nativeIdentity or assignmentId is null it will not 
     * require matching on those fields and all items matching other fields 
     * appName, ni, instance and operation will be returned.
     * 
     * @param appName  Application name
     * @param nativeIdentity Optional native identity
     * @param instance Optional instance
     * @param attrName Optional attribute name
     * @param operation Operation
     * @param assignmentId Assignment ID 
     * @return items list of items that match
     * 
     * @ignore
     * Explain...
     * 
     */
    private List<IdentityRequestItem> findItems(String appName, String nativeIdentity, 
                                                String instance, String attrName, 
                                                String operation, String assignmentId) {
        
        List<IdentityRequestItem> items = new ArrayList<IdentityRequestItem>();
        if ( Util.size(_items) > 0 ) {
            for ( IdentityRequestItem item : _items ) {
                if ( item == null ) continue;
                String app = item.getApplication();
                String inst = item.getInstance();
                String ni = item.getNativeIdentity();
                String attr = item.getName();
                String op = item.getOperation();
                if ( ( ( attrName == null ) || ( Util.nullSafeCompareTo(attr, attrName)  == 0 ) ) &&
                     ( ( nativeIdentity == null ) || ( Util.nullSafeCompareTo(ni, nativeIdentity) == 0) ) &&
                     ( Util.nullSafeCompareTo(inst, instance)  == 0) &&
                     ( Util.nullSafeCompareTo(op, operation)  == 0) &&
                     ( Util.nullSafeCompareTo(appName, app)  == 0 ) &&
                     matchesAssignmentId(item, assignmentId) ) 
                {
                        items.add(item);
                }
            }
        }
        return ( Util.size(items) > 0 ) ? items : null;
    }
    
    //assignmentId could be null
    private boolean matchesAssignmentId(IdentityRequestItem item, String assignmentId) {
        if (assignmentId == null) {
            return true;
        }
        
        //this is for unit test. since the identity request is generated by 
        //master plan, which does not have assignment id.
        if (AssignmentExpander.isTemporaryAssignmentId(assignmentId)) {
            return true;
        }
        
        ProvisioningPlan plan = item.getProvisioningPlan();
        if (plan != null) {
            for (ProvisioningPlan.AccountRequest areq : Util.safeIterable(plan.getAccountRequests())) {
                List<AttributeRequest> attreqs = areq.getAttributeRequests();
                for (AttributeRequest req : Util.iterate(attreqs)) {
                    if (Util.nullSafeEq(assignmentId, req.getAssignmentId())) {
                        return true;
                    }
                }
            }
        }

        // See if it is stored in attributes
        if (item.getAssignmentId() != null) {
            return Util.nullSafeEq(assignmentId, item.getAssignmentId());
        }
        
        return false;
    }

    /**
     * Given an approvalItem return the RequestItems that
     * match up to the approval Item.
     * 
     * This will likely be a single item array, but it
     * could be multiple items if a value
     * represented as a list was flattened in the plan or expanded
     * during the creation of the request.
     * 
     * For IdentityIQ create and update of identity 
     * objects the attributes are always compressed into a single
     * value so an approver only makes one decision. This
     * is because approvers are also allowed to update values
     * in a form that is included in the work item.
     * 
     * @param aitem ApprovalItem to find matching IdentityRequestItems
     * @return items list of items that match approval item
     */
    public List<IdentityRequestItem> findItems(ApprovalItem aitem) {
        String appName = aitem.getApplication();
        String nativeIdentity = aitem.getNativeIdentity();
        String instance = aitem.getInstance();
        String assignmentId = aitem.getAssignmentId();
        String op = opToString(aitem.getOperation());
        
        boolean isNewAccount = ApprovalItemsService.isForceNewAccount(aitem);
        
        Set<IdentityRequestItem> matchedItems = new HashSet<IdentityRequestItem>();
        List<IdentityRequestItem> items = null;
        
        //
        // djs:  Create and Updates being
        // compacted make this messy...
        //        
        boolean iiqCreateOrUpdate = false;
        if ( Util.nullSafeCompareTo(ProvisioningPlan.APP_IIQ, appName) == 0) {            
            // The items will have been flatten turning the 
            // single Modify or Create request into a list 
            // of Set requests
            if ( ( Util.nullSafeCompareTo("Modify", op)  == 0 ) ||  
                 ( Util.nullSafeCompareTo("Create", op) == 0 ) ) {
                op = ProvisioningPlan.Operation.Set.toString();
            }
            // No name indicates this is an IIQ create or Update
            String name = aitem.getName();
            if ( name == null ) {
                // These values for IQ are compacted into one entry with a form.
                // The request model is exploded to an item per attribute value
                // this will ignore the item name assuming they are grouped 
                // in a single item.
                items = findItems(appName, nativeIdentity, instance, null, op, assignmentId);
                if ( items != null )
                    matchedItems.addAll(items);
                
                // Make sure we return the item that represents the Create
                // if we have a create
                if ( Util.nullSafeCompareTo("Create", aitem.getOperation()) == 0 ) {
                    items = findItems(appName, nativeIdentity, instance, null, aitem.getOperation(), assignmentId);
                    if ( items != null )
                        matchedItems.addAll(items);
                }
                // set a flag to avoid looking u based on name
                iiqCreateOrUpdate = true;
            }        
        } 
        if ( !iiqCreateOrUpdate ) {
            // match on attribute name and the values in the item
            items = findItems(appName, nativeIdentity, instance, aitem.getName(), op, assignmentId);
            if (Util.size(items) > 0) {                
                if ( ObjectUtil.isSecret(aitem.getName()) || aitem.getValue() == null  )  {
                    // can't match on value
                    matchedItems.addAll(items);
                } else {
                    List<String> approvalValues = aitem.getValueList();
                    if (approvalValues != null) {
                        for (IdentityRequestItem item : items) {
                            List<String> itemValues = item.getValueList();
                            if (matches(itemValues, approvalValues)) {
                                matchedItems.add(item);
                            }
                        }
                    }
                }
            }
        }
        
        /*
         * IIQETN-243 Looking for items related to account creation request.
         */
        if (isNewAccount) {
            items = findItems(appName, null, null, null, "Create", null);
            if (Util.size(items) > 0) {
                matchedItems.addAll(items);
            }
        }
        
        return new ArrayList<>(matchedItems);
    }
    
    /**
     * 
     * Given an AccountRequest find the RequestItem(s) that
     * map to the account request.
     * 
     * With account requests there is not an attribute name 
     * or value so the search is only on application, nativeIdentity,
     * instance and op. 
     * 
     * @param req AccountRequest to match 
     * @return list of items that match account request
     */
    @SuppressWarnings("unchecked")
    public List<IdentityRequestItem> findItems(ProvisioningPlan.AccountRequest req) {
        
        Set<IdentityRequestItem> items = new HashSet<>();
        
        String appName = req.getApplication();
        String nativeIdentity = req.getNativeIdentity();
        String instance = req.getInstance();
        
        // no attribute name for Account Request
        String attrName = null;
        String op = opToString(req.getOperation());
        
        // During create requests there can be changes of an accountId change
        // so if not found by exact match loosen up and ignore accountId
        boolean isCreate = Util.nullSafeEq(Operation.Create, req.getOperation());        
        List<IdentityRequestItem> reqItems = findItems(appName, nativeIdentity, instance, attrName, op, null);
        if ( Util.size(reqItems) == 0 ) {
            if ( isCreate )                           
                reqItems = findItems(appName, null, instance, attrName, op, null);
        }
        if ( Util.size(reqItems) > 0 ) 
            items.addAll(reqItems);    
        
        // Get all of the flattened request items too
        List<AttributeRequest> attrRequests = req.getAttributeRequests();
        if ( Util.size(attrRequests) > 0 ) {
            for ( AttributeRequest attrRequest : attrRequests) {
                List<Object> values = Util.asList(attrRequest.getValue());
                if ( Util.size(values) > 0 ) {
                    for ( Object val : values ) {
                        if ( val != null ) {
                            IdentityRequestItem found = findItem(req, attrRequest, val.toString());
                            if ( found == null) {
                                if ( isCreate )                            
                                    found = findItem(req, attrRequest, val.toString(), true);                                    
                                                                
                            }
                            if ( found != null )
                                items.add(found);
                        }
                    }
                } else {
                    IdentityRequestItem found = findItem(req, attrRequest, null);
                    if ( found != null)
                        items.add(found);                    
                }
            }
        }        
        return new ArrayList<>(items);
    }
    
    /**
     * Return the item that matches the AccountRequest
     * and GenericRequest combination.
     * 
     * When dealing with AccountRequests that do not
     * have attribute requests all the information
     * is taken from the AccountRequest.
     * 
     * @param req AccountRequest to match
     * @param attrReq GenericRequest (AttributeRequest or PermissionRequest) to match
     * @param valueStr Value as a string
     * @return request item that matches the request
     */
    public IdentityRequestItem findItem(ProvisioningPlan.AccountRequest req, 
                                        ProvisioningPlan.GenericRequest attrReq,
                                        String valueStr) {
        return findItem(req,attrReq, valueStr, false);        
    }
    
    /**
     * Search through the items looking for a matching IdentityRequestItem
     * ignoring the accountId.
     *
     * @param req AccountRequest to match
     * @param attrReq GenericRequest (AttributeRequest or PermissionRequest) to match
     * @param valueStr Value as a string
     * @param ignoreAccountId True if account ID should not be considered in matching
     * @return The matching IdentityRequestItem or null if not found.
     */
    public IdentityRequestItem findItem(ProvisioningPlan.AccountRequest req, 
                                        ProvisioningPlan.GenericRequest attrReq,
                                        String valueStr, 
                                        boolean ignoreAccountId) {
        
        String appName = req.getApplication();
        String nativeIdentity = req.getNativeIdentity();
        if ( ignoreAccountId ) {
            nativeIdentity = null;
        }
        String instance = req.getInstance();
        String op = opToString(req.getOperation());
        
        String att = null;
        if ( attrReq != null ) {
            att = attrReq.getName();
            op = opToString(attrReq.getOperation());
        }

        //match assignmentId
        String assignmentId = attrReq == null ? null : attrReq.getAssignmentId();
        List<IdentityRequestItem> items = findItems(appName, nativeIdentity, instance, att, op, assignmentId);
        if ( Util.size(items) > 0 ) {
            if ( ( Util.size(items) == 1 ) && ( attrReq == null ) )
                return items.get(0);
            
            // for password we don't store values so don't compare
            // move isSecret to somewhere else...
            if ( ( Util.size(items) == 1 ) && (  ObjectUtil.isSecret(att) ) )   
                return items.get(0); 
        
            for ( IdentityRequestItem it : items ) {
                String itemVal = it.getCsv();
                if ( Util.nullSafeCompareTo(valueStr, itemVal) == 0 ) {
                    return it;
                }
            }
        }
        
        return null;
    
    }


    /**
     * Returns true if there are no items pending provisioning.
     * @return true when all things are complete
     */
    public boolean provisioningComplete() {
        return ( Util.size(getPendingProvisioning()) > 0 ) ? false : true; 
    }
    
    /**
     * Returns a list of Items that are pending provisioning. 
     * This means they are not provisioning complete and has 
     * not been rejected, filtered or provisioning has already
     * failed.
     * 
     * @return items list of items pending provisioning
     */
    public List<IdentityRequestItem> getPendingProvisioning() {
        List<IdentityRequestItem> items = new ArrayList<IdentityRequestItem>();
        if ( Util.size(_items) > 0 ) {
            for ( IdentityRequestItem item : _items ) {
                if ( ( item != null ) && 
                     ( !item.isProvisioningComplete() ) &&
                     ( !item.isProvisioningFailed() ) &&
                     ( !item.isNonverifiable() ) && 
                     ( !item.isRejected()) && 
                     ( !item.isFiltered() ) )
                    items.add(item);
            }
        }
        return ( Util.size(items) > 0 ) ? items : null;
    }
    
    @XMLProperty(mode=SerializationMode.UNQUALIFIED)
    public Attributes<String, Object> getAttributes() {
        return _attributes;
    }

    public void setAttributes(Attributes<String, Object> attributes) {
        _attributes = attributes;
    }
    
    public void setAttribute(String name, Object value) {
        setPseudo(name, value);
    }
    
    public Object getAttribute(String name) {
        return Util.get(_attributes, name);
    }
    
    public String getStringAttribute(String name) {
        return Util.getString(_attributes, name);
    }
    
    @XMLProperty
    public Date getVerified() {
        return _verified;
    }

    public void setVerified(Date verificationDate) {
        _verified = verificationDate;
    }
    
    /**
     * This is the same as the created date.
     * @return end date of the request
     */
    @XMLProperty
    public Date getEndDate() {
        return _endDate;
    }

    public void setEndDate(Date end) {
        _endDate = end;
    }

    @XMLProperty
    public String getType() {
        return _type;
    }

    public void setType(String type) {
        _type = type;
    }

    @XMLProperty
    public String getSource() {
        return _source;
    }

    public void setSource(String source) {
        _source = source;
    }

    public Source getSourceObject() {
        Source source = null;
        if  ( _source != null ) 
           source = Source.fromString(_source);
        return source;
    }

    @XMLProperty
    public CompletionStatus getCompletionStatus() {
        return _completionStatus;
    }

    public void setCompletionStatus(CompletionStatus status) {
        _completionStatus = status;
    }
    
    /**
     * If all of the request items have failed, it is a Failure.
     * If they all were successful it is marked a Success, 
     * otherwise its marked Incomplete.
     */
    public void computeCompletionStatus() {

        int retries = Util.size(getProvisioningRetryItems());
        //Don't treat rejected items as pending provisioning -rap
        int pending = Util.size(getPendingProvisioning());
        int failed = Util.size(getProvisioningFailedItems());
        int complete = Util.size(getProvisioningCompleteItems());

        if (_completionStatus == null) {
            // shouldn't be null, so start at the default
            _completionStatus = CompletionStatus.Pending;
        }

        if ( retries > 0) {
            // only incomplete if some are failed
            // otherwise should be pending.
            if (failed > 0) {
                _completionStatus = CompletionStatus.Incomplete;
            }
        }
        else if ( pending == 0 ) {
            int total = complete + failed + pending;
            _completionStatus = CompletionStatus.Incomplete;
            if ( total == failed ) {
               _completionStatus = CompletionStatus.Failure;
            } 
            if ( total == complete ) {
                _completionStatus = CompletionStatus.Success;
            }
        }
    }
    
    @XMLProperty
    public ExecutionStatus getExecutionStatus() {
        return _executionStatus;
    }
    
    public void setExecutionStatus(ExecutionStatus status) {
        _executionStatus = status;
    }    

    
    /**
     * @deprecated - use {@link #isIncomplete()}
     */
    @Deprecated
    public boolean incomplete() {
        return isIncomplete();
    }    
    
    public boolean isIncomplete() {
        return ( _completionStatus != null && CompletionStatus.Incomplete.equals(_completionStatus) ) ? true : false;    
    }
    
    /**
     * @deprecated - use {@link #isFailure()}
     */
    @Deprecated
    public boolean failure() {
        return isFailure();
    }
        
    public boolean isFailure() {
        return ( _completionStatus != null && CompletionStatus.Failure.equals(_completionStatus) ) ? true : false;
    }
       
    /**
     * @deprecated - use {@link #isTerminated()}
     *
     */
    @Deprecated
    public boolean terminated() {
        return isTerminated();
    }
    
    public boolean isTerminated() {
        return ExecutionStatus.Terminated.equals(_executionStatus);
    }

    /**
     * @deprecated use {@link #isExecuting()}
     */
    @Deprecated
    public boolean executing() {
        return isExecuting();
    }

    public boolean isExecuting() {
        return ExecutionStatus.Executing.equals(_executionStatus);
    }
    
    /**
     * Return true when the request has a successful completion
     * status.
     * 
     * @return true when _completionStatus is Success
     */
    public boolean isSuccessful() {
        return CompletionStatus.Success.equals(_completionStatus);
    }
    
    @XMLProperty
    public boolean hasMessages() {
        return _hasMessages;
    }
    
    // for hibernate
    public boolean getHasMessages() {
        return hasMessages();
    }
    
    public void setHasMessages(boolean hasSome) {
        _hasMessages = hasSome;
    }
    
    /**
     * It would be nice if the getter could do this, but its
     * unclear if hibernate would want to mark this dirty
     * if it did. This call will evaluate the messages
     * and mark the flag accordingly.
     */
    public void computeHasMessages() {
        if ( Util.size(getMessages()) > 0 ) {
            _hasMessages = true;
        } else 
            _hasMessages = false;
    }
     
    @XMLProperty
    public String getExternalTicketId() {
        return _externalTicketId;
    }

    public void setExternalTicketId(String externalTicketId) {
        this._externalTicketId = externalTicketId;
    }
    
    ///////////////////////////////////////////////////////////////////////////
    //
    // SailPointObject methods
    //
    /////////////////////////////////////////////////////////////////////////

    public static Map<String, String> getDisplayColumns() {
        final Map<String, String> cols = new LinkedHashMap<String, String>();
        cols.put("name", "RequestidId");
        cols.put("targetDisplayName", "Identity");
        cols.put("created", "Launched");
        cols.put("endDate", "Completed");
        cols.put("verified", "Verified" );
        return cols;
    }

    public static String getDisplayFormat() {
        return "%-20s %-32s %-24s %-24s %-10s\n";        
    }
    
    @Override
    public boolean isNameUnique() {
        return false;
    }    
    
    // need this now that IdentityEntitlements can reference
    // items
    public void visit(Visitor v) throws GeneralException {
        v.visitIdentityRequest(this);
    }
    
    ///////////////////////////////////////////////////////////////////////////
    //
    // Convenience Methods for common things stored in the attributes
    // map.
    //
    ///////////////////////////////////////////////////////////////////////////
    
    public static String opToString(Object operation) {
        String str = ( operation != null ) ? operation.toString() : null;
        return (str == null) ? Operation.Modify.toString() : str;
    }

    @SuppressWarnings("unchecked")
    public List<ApprovalSummary> getApprovalSummaries() {
        return ( List<ApprovalSummary>)Util.get(_attributes,ATT_APPROVAL_SUMMARIES);
    }
    
    public void setApprovalSummaries(List<ApprovalSummary> summaries) {
        setPseudo(ATT_APPROVAL_SUMMARIES, summaries);
    }
        
    public ProvisioningProject getProvisionedProject() {
        return (ProvisioningProject)Util.get(_attributes, ATT_PROVISIONED_PROJECT);
    }
    
    /**
     * Set the final project. This method will scrub out passwords.
     * 
     * @param ctx SailPointContext
     * @param project ProvisioningProject to set
     * @throws GeneralException
     */
    public void setProvisionedProject(SailPointContext ctx, ProvisioningProject project)
        throws GeneralException {
        
        // djs : need a clone because we are possibly going to scrub some
        // values
        if ( project != null ) {
            ProvisioningProject clone = (ProvisioningProject)project.deepCopy((XMLReferenceResolver)ctx);
            if ( clone != null) {
                ObjectUtil.scrubPasswords(clone);
                setPseudo(ATT_PROVISIONED_PROJECT, clone);
            }
        } else {
            setPseudo(ATT_PROVISIONED_PROJECT, project);
        }
    }

    public void mergeProvisionedProject(SailPointContext ctx, ProvisioningProject project)
        throws GeneralException {
        if (project != null) {
            if (getAttribute(ATT_PROVISIONED_PROJECT) == null) {
                //Don't currently have a provisioned project set
                setProvisionedProject(ctx, project);
            } else {
                //Someone has already set the provisioned project, merge this project
                ProvisioningProject currentProj = (ProvisioningProject)getAttribute(ATT_PROVISIONED_PROJECT);

                ProvisioningProject clone = (ProvisioningProject)project.deepCopy((XMLReferenceResolver)ctx);
                if ( clone != null) {
                    ObjectUtil.scrubPasswords(clone);

                    for (ProvisioningPlan plan : Util.safeIterable(clone.getPlans())) {
                        // If this plan has a trackingId, then check the plans in the IR project and remove the plan
                        // with the same trackingId.
                        String planTrackingId = plan.getTrackingId();
                        if (Util.isNotNullOrEmpty(planTrackingId)) {
                            Iterator<ProvisioningPlan> currPlanIter = Util.safeIterable(currentProj.getPlans()).iterator();
                            while (currPlanIter.hasNext()) {
                                ProvisioningPlan currentPlan = currPlanIter.next();
                                if (Util.nullSafeEq(planTrackingId, currentPlan.getTrackingId())) {
                                    // Found the plan, now remove and exit loop
                                    currPlanIter.remove();
                                }
                            }
                        }

                        // Add the plan to the current project of the IdentityRequest
                        currentProj.add(plan);
                    }

                    if (currentProj.getMasterPlan() != null) {
                        //Merge the masterPlan
                        currentProj.getMasterPlan().merge(clone.getMasterPlan());
                    }


                }
            }
        }
    }
    
    public boolean isBulkRequest() {
        return Util.getBoolean(_attributes, ATT_BULK_REQUEST);
    }

    public void setBulkRequest(boolean isBulk) {
        setPseudo(ATT_BULK_REQUEST, isBulk);
    }
    
    public String getTaskResultId() {
        return Util.getString(_attributes, ATT_TASK_RESULT_ID);
    }
    
    public void setTaskResultId(String taskResultId) {
        setPseudo(ATT_TASK_RESULT_ID, taskResultId);
    }
    
    public boolean isSuppressedExpansionItems() {
        return Util.getBoolean(_attributes, ATT_SUPPRESSED_EXPANSION_ITEMS);
    }
    
    public void setSuppressedExpansionItems(boolean b) {
        setPseudo(ATT_SUPPRESSED_EXPANSION_ITEMS, ((b) ? "true" : null));
    }
    
    @SuppressWarnings("unchecked")
    public List<Map<String,Object>> getPolicyViolationMaps() {
        return (List<Map<String,Object>>) Util.get(_attributes, ATT_POLICY_VIOLATION_MAPS);    
    }
    
    public void setPolicyViolationMaps(List<Map<String,Object>> violations) {
        setPseudo(ATT_POLICY_VIOLATION_MAPS, violations);
    }
    
    public void setProcessId(String processId) {
        setPseudo(WorkflowCase.RES_WORKFLOW_PROCESS_ID, processId);
    }
    public String getProcessId() {
        return (String)Util.getString(WorkflowCase.RES_WORKFLOW_PROCESS_ID);        
    }
    
    public String getUserFriendlyType() {
        return getUserFriendlyType(null, null);
    }
    
    public String getUserFriendlyType(Locale locale, TimeZone timeZone) {
        String type = _type;
        if ( _type != null ) {
            String mapConversion = null;
            if ( typeConversionMap != null ) 
                mapConversion = typeConversionMap.get(_type);
            if ( mapConversion != null ) {
                Message msg  = new Message(mapConversion);            
                type = msg.getLocalizedMessage(locale, timeZone);
            }
        }
        return type;
    }
    
    // djs: why is this here?
    public void setUserFriendlyType(String type) {
    	return;
    }
    
    /**
     * Returns true if all of the items in the request are
     * rejected.
     * 
     * @return true if all the items are rejected otherwise false
     */
    public boolean isRejected() {                
        List<IdentityRequestItem> items = getItems();
        if ( items != null ) {
            for ( IdentityRequestItem item :  items ) {
                if ( !item.isRejected() ) {                    
                    return false;                    
                }
            }            
        }
        return true;
    }
    
    /**
     * Figure out if this is dealing with an IdentityIQ only request
     * by iterating over all the items and checking for the 
     * IdentityIQ application. 
     * 
     * @return true if all items are targeted at the IIQ application
     */
    public boolean isIIQOnlyRequest() {                
        List<IdentityRequestItem> items = getItems();
        if ( items != null ) {
            int iiq = 0;
            for ( IdentityRequestItem item :  items ) {
                if ( item.isIIQ() ) {                    
                    iiq++;                    
                }
            }      
            if ( iiq == items.size() ) {
                return true;
            }
        }
        return false;
    }
    
    ///////////////////////////////////////////////////////////////////////////
    //
    // Errors and Warnings
    //
    /////////////////////////////////////////////////////////////////////////
    
    /**
     * Get all the error messages
     * @return List of LocalizedMessages where message type='Error', or null.
     */
    public List<Message> getErrors(){
       return getMessagesByType(Message.Type.Error);
    }

    /**
     * Check if there are any error messages
     * @return True if this TaskItem has accumulated any
     * error messages.
     */
    public boolean hasErrors(){
        return getErrors() != null;
    }

    /**
     * Get all the warning messages
     * @return List of LocalizedMessages where message type='Warn', or null.
     */
    public List<Message> getWarnings(){
         return getMessagesByType(Message.Type.Warn);
    }

    /**
     * Check if there are any warning messages
     * @return True if this TaskItem has accumulated any
     * warning messages.
     */
    public boolean hasWarnings(){
        return getWarnings() != null;
    }
    
    public void addMessage(Message message) {
        if ( message != null ) {
            List<Message> messages = getMessages();
            if ( messages == null ) {
                messages = new ArrayList<Message>();
                setMessages(messages);
            }   
            if ( !messages.contains(message) ) {
                 messages.add(message);
            }
        }
    }
    
    public void addMessages(List<Message> messages)  {
        if ( Util.size(messages) > 0 ) {
            for ( Message msg : messages ) {
                addMessage(msg);
            }
        }
    }
    
    /**
    * Get all messages of the given type
    * @param type Type of message to retrieve
    * @return List of messages matching the given type, or null if none were found.
    */
   public List<Message> getMessagesByType(Message.Type type) {
       List<Message> messages = getMessages();
       if (messages == null || messages.isEmpty() || type==null)
           return null;

       List<Message> matchingMsgs = new ArrayList<Message>();
       for(Message msg : messages){
           if (msg.isType(type))
               matchingMsgs.add(msg);
       }
       return !matchingMsgs.isEmpty() ? matchingMsgs : null;
   }
   
    @SuppressWarnings("unchecked")
    public List<Message> getMessages() {
        return (List<Message>)Util.get(_attributes, ATT_MESSAGES);
    }
    
    public void setMessages(List<Message> messages) {
        setPseudo(ATT_MESSAGES, messages);
    }

    private void setPseudo(String name, Object value) {
        if (value == null) {
            if (_attributes != null)
                _attributes.remove(name);
        }
        else {
            if (_attributes == null)
                _attributes = new Attributes<String,Object>();
            _attributes.put(name, value);
        }
    }
    
    ///////////////////////////////////////////////////////////////////////////
    //
    // Utility
    //
    ///////////////////////////////////////////////////////////////////////////
    
    
    /**
     * Go through the items values and make sure they are all
     * found in the values list.
     * 
     * This is used to find RequestItems based on the values in
     * approvals, account requests which might not be flattened
     * like the request model.
     * 
     * @param itemValues List of values on the item
     * @param values List of values to find
     * @return matches true when if all items and values are found
     */
    private boolean matches(List<String> itemValues, List<String> values) {
        
        if ( Util.size(itemValues) == 0  && Util.size(values) == 0) {
            return true;
        }

        // 
        // Compare the values in the plan against the request
        //
        if ( Util.size(itemValues) > 0 ) {
            if ( ( Util.size(itemValues) == 1 ) &&  
                 ( Util.size(values) == 1 ) ) { 
                if (Util.nullSafeCompareTo(itemValues.get(0), values.get(0).toString()) == 0)
                    return true;
            } else {
                if ( Util.size(values) > 0 ) {
                    // Check to see if all of the values
                    // from the item are in the incomming value
                    // list
                    List<String> allValues = new ArrayList<String>(itemValues);
                    for ( Object o : values ) {
                        if ( o != null ) {
                            String oStr = Util.otoa(o);
                            if ( oStr != null ) {
                                for ( String itemValue : itemValues ) {
                                    if ( Util.nullSafeCompareTo(oStr, itemValue) == 0 ) {
                                        allValues.remove(itemValue);
                                    }
                                }
                            }
                        }
                        // If we found all values return true
                        if ( Util.size(allValues) == 0 ) {
                            return true;
                        }                                                    
                    }
                }
            }        
        }
        return false;
    }    

}
