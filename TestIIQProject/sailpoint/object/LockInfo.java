/* (c) Copyright 2008 SailPoint Technologies, Inc., All Rights Reserved. */

/**
 * Helper class for manging the SailPointObject._lock property.
 *
 * The lock property is a string formatted using a delimiter
 * between the sub-fields.  This class provides a parser for that
 * string and a more convenient programming model.
 *
 * Author: Jeff
 *
 * Originally the "name" was intended to be a meaningful user or task
 * name so we could try to detect who left a dangling lock.  In practice
 * that didn't work because it is too easy to have the same name in use
 * by two different threads and they both think they own the lock.  Later
 * during 5.x the important core tasks (agg/refresh/provisioning) were changed
 * to use Util.uuid() for the lock name.  No system code should be using 
 * a non-generated lock name now, but it is unclear if old custom code still
 * does.  The PersistenceManager and ObjectUtil methods are maintained for
 * backward compatibility but marked deprecated.
 * 
 * In 7.0 in an attempt to catch improper lock "stealing" we allocate
 * a single uuid for lock names and store it in a thread local.  System 
 * code is expected to use locking methods that use the static methods in 
 * this class to maintain that uuid.  In the persistence layer, our interceptor
 * will check locks in objects being flushed to make sure that the thread
 * id matches the id in the lock.
 * 
 */

package sailpoint.object;

import java.io.Serializable;
import java.util.Date;

import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;

import sailpoint.tools.GeneralException;
import sailpoint.tools.Util;
import sailpoint.tools.xml.AbstractXmlObject;
import sailpoint.tools.xml.XMLClass;
import sailpoint.tools.xml.XMLProperty;

/**
 * Helper class for managing the SailPointObject.lock property.
 *
 * The lock property is a string formatted using a delimiter
 * between the sub-fields. This class provides a parser for that
 * string and a more convenient programming model.
 */
@XMLClass
public class LockInfo extends AbstractXmlObject
  implements Serializable {

    //////////////////////////////////////////////////////////////////////
    //
    // Fields
    //  
    //////////////////////////////////////////////////////////////////////

    private static final Log log = LogFactory.getLog(LockInfo.class);

    /**
     * The default lock lock timeout in minutes. This can be overridden
     * in the system configuration.
     */
    public static final int DEFAULT_LOCK_TIMEOUT = 5;

    /**
     * The default lock timeout in minutes for tasks that run a long time.
     * This value will be used if the {@link Configuration#LONG_RUNNING_LOCK_TIMEOUT} is not set.
     */
    public static final int DEFAULT_LONG_LOCK_TIMEOUT = 30;
    
    /**
     * The maximum lock timeout allowed. Unlike like most
     * parameters it is important that this one have a reasonable value, 
     * so if the user just types 99999 in the config page,
     * it is brought back to something reasonable to reality.
     *
     * Two hours should be more than enough to hold onto something.
     */
    public static final int MAX_LOCK_TIMEOUT = 120;

    /**
     * The active lock timeout, taken from the system configuration.
     */
    static int _timeout;
 
    /**
     * Formerly a user specified name for the lock, now expected to be
     * a uuid generated by the static methods in this class.
     */
    String _name;

    /**
     * The date the lock was acquired.
     */
    Date _acquired;

    /**
     * The date the lock was expires.
     * This can be null, in which case the expiration will be 
     * calculated at runtime relative to _acquired using a configurable 
     * expiration.
     */
    Date _expiration;

    /**
     * Optional extra information about the thread that aquired the lock.
     * When set this is typically a TaskDefinition name used to diagnose
     * the source of lock leaks.
     */
    String _context;

    //////////////////////////////////////////////////////////////////////
    //
    // Static Accessors
    //  
    //////////////////////////////////////////////////////////////////////

    public void setLockTimeout(int minutes) {
        _timeout = minutes;
    }

    public int getLockTimeout() {
        return _timeout;
    }

    /**
     * Assimilate configuration options.
     * This is intended to be called by InternalContext during the
     * initial bootstrapping of the first prototype context.
     * The system configuration object is known and can be accessed to pull
     * out interesting things.
     */
    static public void setConfiguration(Configuration config) {

        _timeout = config.getInt(Configuration.LOCK_TIMEOUT);
    }

    //////////////////////////////////////////////////////////////////////
    //
    // Constructor/Properties
    //  
    //////////////////////////////////////////////////////////////////////

    /**
     * Create a new lock for this thread.  
     * The lock name will be automatically taken from the thread local.
     */
    public LockInfo() {
    }
    
    /**
     * Recover a lock from it's serialized representation.
     */
    public LockInfo(String src) throws GeneralException {
        parse(src);
    }

    /**
     * Recover a lock from another object.
     * @ignore
     * I don't see why this is here, if the other object doesn't have 
     * a lock set we'll still build an empty LockInfo.
     */
    @Deprecated
    public LockInfo(SailPointObject obj) throws GeneralException {
        parse(obj.getLock());
    }

    /**
     * Set the lock name.
     * This is no longer to be used in system code, all system code
     * must use the automatically generated id for this thread.
     */
    @Deprecated
    @XMLProperty
    public void setName(String name) {
        _name = name;
    }

    /**
     * Get the unique id of the thread that owns this lock.
     * This is normally generated by the getThreadLockId method in this class.
     * Prior to 5.0 it was sometimes a user specified name.
     */
    public String getName() {
        return _name;
    }

    @XMLProperty
    public void setAcquired(Date d) {
        _acquired = d;
    }

    /**
     * The date the lock was acquired.
     */
    public Date getAcquired() {
        return _acquired;
    }

    @XMLProperty
    public void setExpiration(Date d) {
        _expiration = d;
    }

    /**
     * The date the lock was expires.
     * This can be null, in which case the expiration will be 
     * calculated at runtime relative to <code>acquired</code>
     *  using a configurable expiration.
     */
    public Date getExpiration() {
        return _expiration;
    }

    /**
     * Optional extra information about the thread that aquired the lock.
     * When set this is typically a TaskDefinition name used to diagnose
     * the source of lock leaks.
     */
    @XMLProperty
    public void setContext(String s) {
        _context = s;
    }
    
    public String getContext() {
        return _context;
    }

    //////////////////////////////////////////////////////////////////////
    //
    // Refresh
    //
    //////////////////////////////////////////////////////////////////////

    /**
     * Increment the lock expiration by some number of minutes.
     */
    public void refresh(int minutes) {

        Date now = new Date();
        
        if (_acquired == null)
            _acquired = now;

        // fix invalid minutes, locks must always have a reasonable timeout
        if (minutes <= 0)
            minutes = DEFAULT_LOCK_TIMEOUT;
        else if (minutes > MAX_LOCK_TIMEOUT)
            minutes = MAX_LOCK_TIMEOUT; 

        _expiration = Util.incrementDateByMinutes(now, minutes);
    }

    public void refresh() {

        refresh(_timeout);
    }

    public boolean isExpired() {

        return (_expiration != null && !_expiration.after(new Date()));
    }

    //////////////////////////////////////////////////////////////////////
    //
    // Parsing/Rendering
    //
    //////////////////////////////////////////////////////////////////////

    /**
     * The format of the lock string will look like this:
     *
     *    name|acquired|expired|context
     *
     * This allows you to search on locks for a particular user
     * with a LIKE from the beginning up to the first |.  It does
     * mean that | is not allowed in names but that is a reasonable restriction.
     *
     * If a name with a | is found it will be escaped with backslash
     * so they can be at least gotten in and out without corruption. You
     * will not be able search on the entire name though since LIKE does not
     * understand the escaping convention.
     * 
     * @ignore
     * TODO: Need to formalize our naming restrictions, this isn't the
     * only one.
     *
     * jsl - this is obsolete now, name is always a uuid so you're
     * never going to search on them.  context was added to help diagnose
     * lock leaks.
     *
     */
    public String render() {
        String str = null;

        // Starting in 7.0, if a name has not been set yet, we
        // get the one for this thread.  This should be the usual
        // way LockInfos are now created by the system.
        if (_name == null) {
            _name = getThreadLockId();
        }

        // optional information about the thread
        if (_context == null) {
            _context = sailpoint.api.LockTracker.getLockContext();
        }

        StringBuilder b = new StringBuilder();

        // don't really need escaping now that they're always uuids
        for (int i = 0 ; i < _name.length() ; i++) {
            char ch = _name.charAt(i);
            if (ch == '\\' || ch == '|')
                b.append("\\");
            b.append(ch);
        }
        
        b.append("|");
        if (_acquired != null)
            b.append(_acquired.getTime());

        b.append("|");
        if (_expiration != null)
            b.append(_expiration.getTime());

        if (_context != null) {
            b.append("|");
            // in theory should escape here too, but TaskNames should be behaved
            b.append(_context);
        }

        str = b.toString();

        // unit tests have some very long task names so make sure
        // we don't overflow the lock column
        str = Util.truncate(str, 128);

        return str;
    }
    
    public void parse(String src) throws GeneralException {
        
        _name = null;
        _acquired = null;
        _expiration = null;
        _context = null;
        
        if (src != null) {
            // isolate the name, could use Tokenizer but the escaping
            // makes this more complicated
            StringBuilder b = new StringBuilder();

            int psn = nextToken(src, 0, b);
            if (b.length() > 0)
                _name = b.toString();

            psn = nextToken(src, psn + 1, b);
            if (b.length() > 0)
                _acquired = new Date(Util.atol(b.toString()));
            
            psn = nextToken(src, psn + 1, b);
            if (b.length() > 0)
                _expiration = new Date(Util.atol(b.toString()));
            
            psn = nextToken(src, psn + 1, b);
            if (b.length() > 0)
                _context = b.toString();
        }
    }

    private int nextToken(String src, int psn, StringBuilder b) {
        
        b.setLength(0);

        boolean escaped = false;
        for ( ; psn < src.length() ; psn++) {
            char ch = src.charAt(psn);
            if (escaped) {
                b.append(ch);
                escaped = false;
            }
            else if (ch == '\\')
                escaped = true;
            else if (ch != '|')
                b.append(ch);
            else
                break;
        }
        return psn;
    }

    public String describe() {

        StringBuilder b = new StringBuilder();

        if (_name == null) {
            b.append("Lock has no id");
        }
        else {
            b.append("Lock id ");
            b.append(_name);
            if (_acquired != null) {
                b.append(" on ");
                b.append(Util.dateToString(_acquired));
            }
            if (_expiration != null) {
                b.append(" expires ");
                b.append(Util.dateToString(_expiration));
            }
            if (_context != null) {
                b.append(" from ");
                b.append(_context);
            }
        }

        return b.toString();
    }

    public void print() {

        System.out.println(describe());
    }

    /**
     * Verify that an object lock was held and has not expired.
     * Used by agg and refresh to log expiration errors.
     */
    public static void verify(SailPointObject obj, String task) {
                                        
        String lockString = obj.getLock();

        // ugh, this is typically wrapped by Hibernate and comes out as
        // Identity$HibernateProxy$qpLPtE1N
        // Use this Hibernate utility to get the real name, unfortunately
        // HibernatePersistenceManager.getTheClass is not accessible, I thought
        // sure we had a utility for this
        Class cls = org.hibernate.Hibernate.getClass(obj);
        String className = cls.getSimpleName();

        if (lockString == null) {
            // this should never happen any more
            log.error(cls + " reached end of " + task + " without lock: " + obj.getName());
        }
        else {
            // this can happen
            try {
                LockInfo lock = new LockInfo(lockString);
                if (lock.isExpired()) {
                    log.error(task + " lock expired for " + className + ": " + obj.getName());
                }
            }
            catch (Throwable t) {
                // must have been a parse error
                log.error(task + " lock invalid for " + className + ": " + obj.getName());
            }
        }
    }
    
    //////////////////////////////////////////////////////////////////////
    //
    // Thread Lock Id
    //
    //////////////////////////////////////////////////////////////////////

    /**
     * Unique id for this thread.  Formerly we let this be defined
     * by the task, but now we should just let everything use the
     * generated uuid.
     */
    static ThreadLocal<String> LockId = new ThreadLocal<String>();

    /**
     * Return the unique locking id for this thread.  This may be used
     * in system code to generate the "lockName" argument that appears in 
     * many methods, but it should all eventually migrate to not passing
     * an explicit lockName and letting it auto-generate in render().
     */
    public static String getThreadLockId() {

        String id = LockId.get();
        if (id == null) {
            id = Util.uuid();
            LockId.set(id);
        }
        return id;
    }

    /**
     * Return the unique locking id for this thread if one exists.
     * This is intended only for Hibernate layer code to check to see
     * if a locking id was property generated.
     */
    public static String peekThreadLockId() {
        return LockId.get();
    }
    
    /**
     * Set the lock context information.  Tasks should remember to 
     * unset this when they're done.  Moved to LockTracker,
     * leave these old method behind so we efix less code.
     */
    public static void setThreadLockContext(String s) {
        sailpoint.api.LockTracker.setThreadContext(s);
    }

    public static String getThreadLockContext() {
        return sailpoint.api.LockTracker.getThreadContext();
    }
    
}

