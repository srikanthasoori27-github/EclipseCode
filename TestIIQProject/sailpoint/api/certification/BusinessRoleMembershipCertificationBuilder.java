/* (c) Copyright 2008 SailPoint Technologies, Inc., All Rights Reserved. */

package sailpoint.api.certification;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;

import sailpoint.api.CertificationContext;
import sailpoint.api.EntitlementCorrelator;
import sailpoint.api.ObjectUtil;
import sailpoint.api.SailPointContext;
import sailpoint.object.AbstractCertifiableEntity;
import sailpoint.object.Bundle;
import sailpoint.object.Certifiable;
import sailpoint.object.Certification;
import sailpoint.object.CertificationDefinition;
import sailpoint.object.CertificationItem;
import sailpoint.object.Filter;
import sailpoint.object.Identity;
import sailpoint.object.QueryOptions;
import sailpoint.object.RoleAssignment;
import sailpoint.object.RoleDetection;
import sailpoint.object.RoleTarget;
import sailpoint.tools.GeneralException;
import sailpoint.tools.Message;
import sailpoint.tools.Util;
import sailpoint.web.identity.RoleAssignmentUtil;
import sailpoint.web.identity.RoleDetectionUtil;
import sailpoint.web.messages.MessageKeys;

/**
 * Builder for Business Role Membership Certifications. The certification population
 * is determined by business role membership and the only entitlements certified are business roles.
 * Otherwise it functions in the same manner as other identity certification types.
 *
 * @author <a href="mailto:jonathan.bryant@sailpoint.com">Jonathan Bryant</a>
 */
public class BusinessRoleMembershipCertificationBuilder extends BaseIdentityCertificationBuilder{

    private static final Log log = LogFactory.getLog(BusinessRoleMembershipCertificationBuilder.class);

    // cached list of identities who are the assignee of last resort if an identity does not
    // have a manager or if a role does not have an owner.
    private List<Identity> defaultAssignees = null;

    // ID of the roles to certify
    private Set<String> businessRoleIds = new HashSet<String>();
    private List<String> roleTypes;

    /**
     *
     * @param ctx SailPointContext instance.
     * See CertificationExecutor.CertifierSelectionType
     */
    public BusinessRoleMembershipCertificationBuilder(SailPointContext ctx, CertificationDefinition definition, EntitlementCorrelator correlator){
        super(ctx, definition, correlator);

        if (!definition.isGlobal()) {
            List<String> roleIds = ObjectUtil.convertToIds(ctx, Bundle.class, definition.getBusinessRoleIds());
            if (!Util.isEmpty(roleIds)){
                businessRoleIds.addAll(roleIds);
            }
        }

        this.roleTypes = definition.getRoleTypes();
    }

    /* (non-Javadoc)
     * @see sailpoint.api.CertificationBuilder#getContext(Certification)
     */
    public CertificationContext getContext(Certification cert) throws GeneralException {

        // We don't store the necessary info now, but role certs aren't reactive
        // either so we will just throw.
        throw new GeneralException("getContext(Certification) not yet supported - " +
                                   "context needs to implement storeContext().  This " +
                                   "is only needed for reactive certifications.");
    }

    /**
     * Returns contexts for the business roles passed to the builder in the
     * constructor.
     *
     * @return CertificationContexts generated by the builder parameters.
     * @throws GeneralException
     */
    public Iterator<CertificationContext> getContexts() throws GeneralException {

        assert (this.global || !businessRoleIds.isEmpty()) :
                "Expect either global or at least one business role";

        List<CertificationContext> ctxs = new ArrayList<CertificationContext>();

        // If this is a global cert, or if the user has chosen to certify
        // by role type, look up the roles we need to certify
        if (global || (roleTypes != null && !roleTypes.isEmpty())){

            Identity defOwner = definition.getOwner();
            try {
                // When we do global certs, we need to make sure that the roles
                // applied to the cert are within the cert def owner's scope, 
                // so impersonate
                context.impersonate(defOwner);
                context.setScopeResults(true);
    
                QueryOptions ops = new QueryOptions();
                ops.addOwnerScope(defOwner);
    
                if (roleTypes != null && !roleTypes.isEmpty())
                    ops.add(Filter.in("type", roleTypes));
    
                Iterator<Object[]> bundleIds = context.search(Bundle.class, ops, Arrays.asList("id"));
                while (bundleIds.hasNext()) {
                    businessRoleIds.add((String)bundleIds.next()[0]);
                }
            } finally {
                // If anything bad should happen or we're done, make sure we 
                // reveal our true identity before going on.
                context.impersonate(null);
                context.setScopeResults(false);
            }                
        }

        CertificationDefinition.CertifierSelectionType certifierType = definition.getCertifierSelectionType();
        if (CertificationDefinition.CertifierSelectionType.Owner.equals(certifierType)){
            ctxs.addAll(getRoleOwnerCertifications());
        } else if (CertificationDefinition.CertifierSelectionType.Manager.equals(certifierType)){
            ctxs.addAll(getManagerCertifications());
        } else if (CertificationDefinition.CertifierSelectionType.Manual.equals(certifierType)){
            // if they didn't specify a certifier just assign to managers
            if (getOwners() == null || getOwners().isEmpty())
                ctxs.addAll(getManagerCertifications());
            else
                ctxs.add(newContext(context, getRoleMemberNames(businessRoleIds), businessRoleIds, getOwners()));
        }else{
            throw new RuntimeException("Unknown certifier type '"+certifierType+"'.");
        }

        if (ctxs.isEmpty())
            return null;

        return ctxs.iterator();
    }

    /**
     * IIQCB-1409 if role comp cert certifier selection type is role owner or manager we want to ignore the manual selections
     */
    @Override
    public List<Identity> getOwners() {
        if (definition.getCertifierSelectionType() == CertificationDefinition.CertifierSelectionType.Owner
            || definition.getCertifierSelectionType() == CertificationDefinition.CertifierSelectionType.Manager) {
            return null;
        }
        else
            return super.getOwners();
    }

    /**
     * Creates certification contexts in cases where the certifications were intended to
     * be assigned to the role owners. If any of the given roles do not have
     * an owner, a warning is created.
     *
     * @return List of CertificationContexts or an empty list.
     * @throws GeneralException
     */
    private List<CertificationContext> getRoleOwnerCertifications() throws GeneralException{

        List<CertificationContext> ctxs = new ArrayList<CertificationContext>();
        Map<String, Set<String>> roleAssignments = getRoleOwnerAssignments();

        // Create a certification context for each role owner containing the
        // members of all the roles they own.
        for(String roleOwnerName : roleAssignments.keySet()){
            List<Assignment> assignments = new ArrayList<Assignment>();
            Set<String> roleMembers = getRoleMemberNames(roleAssignments.get(roleOwnerName));
            for(String roleMember : roleMembers){
                assignments.add(new Assignment(roleMember, roleAssignments.get(roleOwnerName)));
            }

            Identity roleOwner = context.getObjectByName(Identity.class, roleOwnerName);
            List<Identity> certOwner = Arrays.asList(roleOwner);
            ctxs.add(newContext(context, assignments, certOwner));
        }

        return ctxs;
    }

    /**
     * Returns a map that associates the roles included in the certification with
     * their owners.
     *
     * @return Map associating identities with the roles they own.
     * @throws GeneralException
     */
    private Map<String, Set<String>> getRoleOwnerAssignments() throws GeneralException{

        Map<String, Set<String>> roleOwnership = new HashMap<String, Set<String>>();

        // Get a list of all the role owners, grouping them with the set of role IDs they own
        if (businessRoleIds != null){
           List<String> fields =  Arrays.asList("name", "owner.name");
           for(String id : businessRoleIds){
               Iterator<Object[]> result = context.search(Bundle.class, new QueryOptions(Filter.eq("id", id)), fields);
               Object[] row = result.next();
               String roleName = (String)row[0];
               String ownerName = (String)row[1];
               if (ownerName != null){
                   if (!roleOwnership.containsKey(ownerName))
                       roleOwnership.put(ownerName, new HashSet<String>());
                   roleOwnership.get(ownerName).add(id);
               }else{
                    addWarning(new Message(MessageKeys.SOME_IDENTITIES_NOT_ADDED_TO_ROLE_CERT,
                            roleName));
               }

           }
        }

        return roleOwnership;
    }

    /**
     * Gets a list of the names of the members of the given groups.
     *
     * @param roleIds IDs of the group you want the members of.
     * @return Set of member names for the given groups or an empty set.
     * @throws GeneralException
     */
    private Set<String> getRoleMemberNames(Set<String> roleIds) throws GeneralException{
        Map<String, String> members = getRoleMemberMap(roleIds);

        if (members != null)
            return members.keySet();
        else
            return new HashSet<String>();
    }

    /**
     * List of certification contexts for the roles included in this builder. A certification
     * is created for each manager of the role members. If an identity does not have a manager
     * they are assigned to the role owner. If a role has no owner, a warning is created and the
     * identity is excluded from the certificaiton.
     *
     * @return List of CertificationContext for the roles added to this builder.
     * @throws GeneralException
     */
    private List<CertificationContext> getManagerCertifications() throws GeneralException{

        List<CertificationContext> ctxs = new ArrayList<CertificationContext>();

        Map<String, List<Assignment>> assignments = new HashMap<String, List<Assignment>>();

        Map<String, String> members = getRoleMemberMap(businessRoleIds);
        Set<String> managerLessIdentities = new HashSet<String>();

        // Get all the identities with the roles we're certifying and assign them to their
        // managers. If we can't find a manager, add them to a list so we can deal with the later.
        for(String identityName : members.keySet()){
            String manager = members.get(identityName);
            if (manager == null){
                managerLessIdentities.add(identityName);
            }else if (assignments.containsKey(manager)){
                assignments.get(manager).add(new Assignment(identityName , businessRoleIds));
            }else{
                List<Assignment> assignmentList = new ArrayList<Assignment>();
                assignmentList.add(new Assignment(identityName , businessRoleIds));
                assignments.put(manager, assignmentList);
            }
        }

        // We found some identities without managers. We now must attempt to assign these
        // people to the business role owner. If the role owner doesnt exist(which should not happen)
        // we'll add the role to a list which we'll use to create warnings
        if (!managerLessIdentities.isEmpty()){
            Set<String> ownerlessRoles = new HashSet<String>();
            if (managerLessIdentities!=null){
                for(String identityName : managerLessIdentities) {
                    Identity identity = context.getObjectByName(Identity.class, identityName);
                    if (identity != null){
                        collectAssignments(identityName, identity.getBundles(),
                                           assignments, ownerlessRoles);
                        collectAssignments(identityName, identity.getAssignedRoles(),
                                           assignments, ownerlessRoles);
                    }
                }
            }

            // We attempted to assign some managerless identities to the role owners but could not
            // find a role owner. This should not happen so we'll add a warning and exclude the
            // managerless identities
            if (!ownerlessRoles.isEmpty()){
                for(String roleName : ownerlessRoles){
                    addWarning(new Message(MessageKeys.SOME_IDENTITIES_NOT_ADDED_TO_ROLE_CERT, roleName));
                }

            }         
        }

        for(String assigneeName : assignments.keySet()){
            Identity assignee = context.getObjectByName(Identity.class, assigneeName);
            CertificationContext ctx =new BusinessRoleMembershipCertificationContext(context, definition,
                Arrays.asList(assignee), assignments.get(assigneeName));
            ctx.setCertificationGroups(this.getCertificationGroups());
            ctxs.add(ctx);
        }
        return ctxs;
    }

     private BusinessRoleMembershipCertificationContext newContext(SailPointContext context,
                List<Assignment> assignments, List<Identity> owners){
        BusinessRoleMembershipCertificationContext ctx = new BusinessRoleMembershipCertificationContext(context,
                definition, owners, assignments);
        ctx.setCertificationGroups(this.getCertificationGroups());
        return ctx;
    }

    private BusinessRoleMembershipCertificationContext newContext(SailPointContext context, Set<String> identityNames,
                Set<String> roleIds, List<Identity> owners){
        BusinessRoleMembershipCertificationContext ctx = new BusinessRoleMembershipCertificationContext(context,
                definition, owners, identityNames, roleIds);
        ctx.setCertificationGroups(getCertificationGroups());
        return ctx;
    }

    /**
     * Add Assignments to the assignment list for every role in the given list
     * that is to be certified.
     * 
     * @param  identity        The Identity that has the role assignments.
     * @param  roles           The roles detected or assigned to the identity.
     * @param  assignments     The Assignments by owner to which to add any new
     *                         Assignments.
     * @param  ownerlessRoles  The set of role IDs to which to add roles that
     *                         have no owner.
     */
    private void collectAssignments(String identity, List<Bundle> roles,
                                    Map<String,List<Assignment>> assignments,
                                    Set<String> ownerlessRoles) {
        
        if(null != roles) {
            for(Bundle bundle : roles){
                if(this.businessRoleIds.contains(bundle.getId())){
                    if (bundle.getOwner() == null){
                        ownerlessRoles.add(bundle.getName());
                    } else if (assignments.containsKey(bundle.getOwner().getName())){
                        Assignment assignment = new Assignment(identity
                                , bundle.getId());
                        assignments.get(bundle.getOwner().getName()).add(assignment);
                    } else{
                        List<Assignment> aList = new ArrayList<Assignment>();
                        aList.add(new Assignment(identity, bundle.getId()));
                        assignments.put(bundle.getOwner().getName(), aList);
                    }
                }
            }
        }
    }

    /**
     * Returns map of identity->manager for all Identities that have the given roles
     * as either assigned or detected.
     * We use assignedRoles/Bundles here, due to the fact that these are distinct lists. When
     * generating the certifiables, we will need to use RoleAssignments/RoleDetections in order 
     * to obtain the full list of certifiables.
     */
    private Map<String, String> getRoleMemberMap(Collection<String> roleIds) throws GeneralException{

        Map<String, String> members = new HashMap<String, String>();
        List<String> bundleIdSpecifiers = Util.csvToList("bundles.id,assignedRoles.id");
        if (roleIds != null){
            for (String bundleIdSpec : bundleIdSpecifiers) {
                // build our map in batches of 100 roles
                List<String> roleQueryList = new ArrayList<String>(100);
                for (String roleId : roleIds) {
                    roleQueryList.add(roleId);
                    if (roleQueryList.size() >= 100) {
                        updateRoleMemberMap(members, bundleIdSpec, roleQueryList);
                        roleQueryList = new ArrayList<String>(100);
                    }
                }
                if (roleQueryList.size() > 0) {
                    // make sure the left-overs are included
                    updateRoleMemberMap(members, bundleIdSpec, roleQueryList);
                }
            }
        }

        return members;
    }
    
    private void updateRoleMemberMap(Map<String, String> members, String bundleIdSpec, List<String> roleIds) throws GeneralException {
        QueryOptions qo = new QueryOptions();
        qo.add(Filter.in(bundleIdSpec, roleIds));
        Iterator<Object[]> results =
            context.search(Identity.class, qo, Arrays.asList("name", "manager.name"));
        if (results != null){
            while(results.hasNext()){
                Object[] row = results.next();
                String identity = (String)row[0];
                String manager = (String)row[1];
                members.put(identity, manager);
            }
        }

    }

    /**
     * Certification context for creating business role membership certifications.
     */
    public class BusinessRoleMembershipCertificationContext
        extends BaseIdentityCertificationBuilder.BaseIdentityCertificationContext {
        private Set<String> identityNames = new HashSet<String>();
        private List<Assignment> assignments;


        /**
         * Creates a BusinessRoleMembershipCertificationContext instance for the
         * given set of assignments.
         *
         * @param context An open SailPointContext instance
         * @param assignments List of assignments for this certification
         * @param owners Certification owners. Should be non-null and non-emptu
         * specified by certification creator.
         */
        public BusinessRoleMembershipCertificationContext(SailPointContext context, CertificationDefinition definition,
                                                          List<Identity> owners, List<Assignment> assignments) {
            super(context, definition, owners);
            for(Assignment assignment : assignments){
                this.identityNames.add(assignment.getIdentityName());
            }
            this.assignments = assignments;
        }

        /**
         * Creates a BusinessRoleMembershipCertificationContext instance for the
         * given set of business roles and identities.
         *
         * This is a simpler constructor in that we don't need assignments. The
         * reason being that the list of business roles is the same for all identities.
         * We use assignments in cases where identities don't have managers and the
         * assignment of identities to certifiers is more complex.  
         *
         * @param context A open SailPointContext instance
         * @param roleIds Set of business role IDs to be certified.
         * @param owners Certification owners, or null/empty if owner was not
         * specified by certification creator.
         */
        public BusinessRoleMembershipCertificationContext(SailPointContext context, CertificationDefinition definition,
                                                          List<Identity> owners, Set<String> identityNames,
                                                          Set<String> roleIds) {
            super(context, definition, owners);
            this.identityNames.addAll(identityNames);

            assignments = new ArrayList<Assignment>();
            for(String identityName : identityNames){
                assignments.add(new Assignment(identityName, roleIds));
            }
        }

        @Override
        public boolean isIncludeAdditionalEntitlements() {
            return false;
        }

        @Override
        public boolean isIncludePolicyViolations() {
            return false;
        }

        @Override
        public boolean isIncludeBusinessRoles() {
            return true;
        }


        /**
         * Returns a CertificationEntity instance for each member of the business roles
         * included in this certification.
         *
         * @return List of CertificationEntity instances
         * @throws GeneralException
         */
        public Iterator<? extends AbstractCertifiableEntity> getPopulation() throws GeneralException {

            if (identityNames.isEmpty())
                return null;
            else
                return new IncrementalIdentityIterator(context, identityNames);
        }

        public boolean inPopulation(AbstractCertifiableEntity entity) {
            return this.identityNames.contains(entity.getName());
        }

       /**
         * Get a list of Certifiable objects from the given entity. Retrieves
         * any business roles which are included in the roles specified for this
         * certification.
         *
         * @param  entity The AbstractCertifiableEntity from which to retrieve the
         *  Certifiable items.
         *
         * @return A list of Certifiable objects from the given identity.
         */
        public List<Certifiable> getCertifiables(AbstractCertifiableEntity entity) throws GeneralException {

           Identity identity = (Identity)entity;

           List<Certifiable> certifiables = new ArrayList<Certifiable>();

           Set<String> roleIds = new HashSet<String>();
           for(Assignment assignment : assignments){
               if (assignment.getIdentityName().equals(identity.getName())){
                   roleIds.addAll(assignment.getRoleIds());
               }
           }

           if (!roleIds.isEmpty()) {
               Set<String> assignedRoleIds = new HashSet<String>();
               
               //Look in RoleAssignments for a match
               List<RoleAssignment> assignments = entity.getRoleAssignments();
               if(!Util.isEmpty(assignments)) {
                   for(RoleAssignment ra : assignments) {
                       String assignedRoleId = ra.getRoleId();
                       if (!ra.isNegative() && roleIds.contains(assignedRoleId) && !assignedRoleIds.contains(assignedRoleId)) {
                           certifiables.add(RoleAssignmentUtil.getClonedBundleFromRoleAssignment(context, ra));
                           List<RoleTarget> targets = ra.getTargets();
                           if (!Util.isEmpty(targets)) {
                               for (RoleTarget target : ra.getTargets()) {
                                   assignedRoleIds.add(getAssignmentKey(assignedRoleId, target));
                               }
                           } else {
                               assignedRoleIds.add(getAssignmentKey(assignedRoleId, null));
                           }
                       }
                   }
               }
               
               //Perhaps we could be smarter about cert line items here. Probably don't need to show the detections
               //that won't be removed regardless of the decision (required by a role assignment, etc.)
               List<RoleDetection> detections = entity.getRoleDetections();
               if(!Util.isEmpty(detections)) {
                   for(RoleDetection rd : detections) {
                       String detectedRoleId = rd.getRoleId();
                       List<String> detectedAssignmentKeys = new ArrayList<String>();
                       List<RoleTarget> targets = rd.getTargets();
                       if (!Util.isEmpty(targets)) {
                           for (RoleTarget target : rd.getTargets()) {
                               detectedAssignmentKeys.add(getAssignmentKey(detectedRoleId, target));
                           }
                       } else {
                           detectedAssignmentKeys.add(getAssignmentKey(detectedRoleId, null));
                       }
                       // Don't add the role if it is both assigned and detected because it's already been incorporated into the certification
                       if(roleIds.contains(rd.getRoleId()) && !assignedRoleIds.containsAll(detectedAssignmentKeys)) {
                           if(rd.hasAssignmentIds()) {
                               for(String assignId : rd.getAssignmentIdList()) {
                                   RoleAssignment roleAssignment = ((Identity) entity).getRoleAssignmentById(assignId);
                                   Bundle assignment = RoleAssignmentUtil.getClonedBundleFromRoleAssignment(context, roleAssignment);
                                   Certifiable bundle = RoleDetectionUtil.getClonedBundleFromRoleDetection(context, rd, assignId);

                                   // Don't include a role if it's required by another role, unless requested as part
                                   // of the certification definition.
                                   if (assignment == null || Util.isEmpty(assignment.getRequirements()) ||
                                           definition.getIncludeRequiredRoles() || !assignment.getRequirements().contains(bundle)) {
                                       //Add a certifiable Object for every assignment Id
                                       //NOTE: Acting on these when they are simply "soft permits" with multiple assignmentIds
                                       //will not do anything, as they won't deprovision unless a request is made for all assignmentIds

                                       // Don't add a role if it's already part of the certifiables list.
                                       if (!certifiables.contains(bundle)) {
                                           certifiables.add(bundle);
                                       }
                                   }
                               }
                           } else {
                               //We found a Role Detection for the given role, but without an assignment Id. 
                               certifiables.add(RoleDetectionUtil.getClonedBundleFromRoleDetection(context, rd, null));
                           }
                       }
                   }
               }
           }

           return certifiables;
        }

        @Override
        protected CertificationItem createCertificationItemInternal(Certification cert, Certifiable certifiable, AbstractCertifiableEntity entity) throws GeneralException {
            CertificationItem item = super.createCertificationItemInternal(cert, certifiable, entity);
            Bundle b = (Bundle)certifiable;

            // The BaseIdentityCertificationBuilder assumes that all roles with assignment ids are rolled up into the assigned role
            // However, in the case of this cert, we might have the detected role as a separate item. So first check if the role assignment
            // is for the role in the item, and if not, clear it and get the detection instead.
            // If there is no assignment id, the detection will already have been set in BaseIdentityCertificationBuilder.
            if (b.getAssignmentId() != null &&
                    (item.getRoleAssignment() == null || !Util.nullSafeEq(b.getId(), item.getRoleAssignment().getRoleId()))) {
                item.setRoleAssignment(null);
                item.setRoleDetection(((Identity)entity).getRoleDetection(b.getAssignmentId(), b.getId()));
            }

            return item;
        }

        /*
         * Builds a key to correlate role assignments and detections
         */
        private String getAssignmentKey(String assignedRoleId, RoleTarget target) {
            StringBuilder buff = new StringBuilder();
            buff.append(assignedRoleId);
            if (target != null) {
                buff.append(":").append(target.getApplicationId()).append(":");
                if (!Util.isNothing(target.getInstance())) {
                    buff.append(target.getInstance()).append(":");
                }
                buff.append(target.getNativeIdentity());
            }
        return buff.toString();
    }

        /**
         * Generate a long descriptive name that specifies what the cert is about and
         * why they were assigned the cert. If there's a group owner, add their name.
         * If the cert is being assigned to the app owner b/c there is no group owner,
         * note that the groups to certify had no owner.
         *
         *
         * @return long description of the certification.
         * @throws GeneralException
         */
        String generateDefaultName() throws GeneralException {
            return createName(false);
        }

        /**
         * Creates a short name for the cert which will be used in places like
         * the dashboard where space is a concern.
         *
         * @return descriptive short name of the certification
         * @throws GeneralException
         */
        String generateDefaultShortName() throws GeneralException {
            return createName(true);
        }

        /**
         * Creates either the short or long name for the certification
         *
         * @param shortName True if the certification short name is required
         * @return  Localized certification name
         * @throws GeneralException
         */
        @SuppressWarnings({ "rawtypes", "unchecked" })
        private String createName(boolean shortName) throws GeneralException{
            String key = null;

            List params = new ArrayList();
            params.add(new Message(definition.getType().getMessageKey()));

            if (shortName && getOwners() != null && getOwners().size() == 1){
                key = global ? MessageKeys.CERT_SHORTNAME_GLOBAL_OWNER :
                        MessageKeys.CERT_SHORTNAME_OWNER;
                params.add(getOwners().get(0).getDisplayableName());        
            } else if (!shortName && getOwners().size() == 1) {
                key = global ? MessageKeys.CERT_NAME_GLOBAL_ROLES_OWNER : MessageKeys.CERT_NAME_ROLES_OWNER;
                params.add(getOwners().get(0).getDisplayableName());
            } else if (shortName) {
                key = global ? MessageKeys.CERT_SHORTNAME_GLOBAL : MessageKeys.CERT_SHORTNAME_GENERIC;
            } else {
                key = global ? MessageKeys.CERT_NAME_GLOBAL_ROLES : MessageKeys.CERT_NAME_ROLES;
            }

            Message name = new Message(key, params.toArray());

            return name.getLocalizedMessage();
        }

         @Override
        protected void addNameParameters(CertificationNamer namer){
            namer.addParameter(CertificationNamer.NAME_TEMPLATE_CERTIFIER_NAMES, this.identityNames);
            namer.addParameter(CertificationNamer.NAME_TEMPLATE_GLOBAL, global);
        }

        /**
         * We always retrieve the owner before creating the context, so
         * this method shouldn't be needed.
         *
         * @return Empty identity list
         */
        protected List<Identity> getOwnersInternal() {
            log.warn("Certification context did not contain an owner.");
            
            return new ArrayList<Identity>();
        }
    }

    /**
     * The assignment class allows us to connect an identity and the
     * list of the roles that needs certifying.
     */
    private static class Assignment{

        private String identityName;
        private Set<String> roleIds;

        public Assignment(String identityId, Set<String> roleIds) {
            this.roleIds = new HashSet<String>();
            this.roleIds = roleIds;
            this.identityName = identityId;
        }

        public Assignment(String identityId, String roleId) {
            this.roleIds = new HashSet<String>();
            this.roleIds = new HashSet<String>();
            roleIds.add(roleId);
            this.identityName = identityId;
        }

        public String getIdentityName() {
            return identityName;
        }

        public Set<String> getRoleIds() {
            return roleIds;
        }

        public void setRoleIds(Set<String> roleIds) {
            this.roleIds = roleIds;
        }

        public void addRoleIds(Set<String> roleId){
            roleIds.addAll(roleId);
        }

    }

}
