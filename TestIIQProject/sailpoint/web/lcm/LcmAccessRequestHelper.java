/* (c) Copyright 2014 SailPoint Technologies, Inc., All Rights Reserved. */

/**
 * Package decl.
 */
package sailpoint.web.lcm;

/**
 * Imports.
 */
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;

import sailpoint.api.IdentityService;
import sailpoint.api.ManagedAttributer;
import sailpoint.api.ObjectUtil;
import sailpoint.api.Provisioner;
import sailpoint.api.SailPointContext;
import sailpoint.api.SearchResultsIterator;
import sailpoint.object.AccountSelection;
import sailpoint.object.Application;
import sailpoint.object.Bundle;
import sailpoint.object.Configuration;
import sailpoint.object.Identity;
import sailpoint.object.Link;
import sailpoint.object.ProvisioningPlan;
import sailpoint.object.ProvisioningPlan.AccountRequest;
import sailpoint.object.ProvisioningPlan.AttributeRequest;
import sailpoint.object.ProvisioningProject;
import sailpoint.object.ProvisioningTarget;
import sailpoint.object.QuickLink;
import sailpoint.object.RoleAssignment;
import sailpoint.object.SailPointObject;
import sailpoint.provisioning.PlanCompiler;
import sailpoint.service.CurrentAccessService;
import sailpoint.service.quicklink.QuickLinkOptionsConfigService;
import sailpoint.tools.GeneralException;
import sailpoint.tools.Util;

/**
 * Helper class for compiling provisioning targets and account selections during 
 * an LCM role or entitlement request.
 *
 */
public class LcmAccessRequestHelper {

    /**
     * The context.
     */
    SailPointContext _context;

    /**
     * The currently logged in user.
     */
    Identity _loggedInUser;

    /**
     * The ids of the identities being requested for.
     */
    List<String> _identityIds;

    /**
     * The account requests generated by LCM.
     */
    List<AccountRequest> _accountRequests;

    /**
     * Map from identity id to provisioning targets. This is
     * generated from plan compilation.
     */
    Map<String, List<ProvisioningTarget>> _targetMap;

    /**
     * Map from identity id to provisioning targets. This is set by
     * caller prior to compilation and holds existing selections
     * to be reused.
     */
    Map<String, List<ProvisioningTarget>> _existingTargets;

    /**
     * Name of the quickLink used to configure request authorities
     */
    String _quickLinkName;

    /**
     * Determines if the request is a direct permitted role request, i.e.
     * it was added to the cart from the role search list and not through
     * an assignable role being added to the cart.
     * @param request The request.
     * @return True if is a direct permitted role request, false otherwise.
     */
    public static boolean isDirectPermittedRoleRequest(AccountRequest request) {
        // should only have one attribute request
        if (Util.size(request.getAttributeRequests()) != 1) {
            return false;
        }

        AttributeRequest attrRequest = request.getAttributeRequests().get(0);

        // if request is for detectedRoles and has no permittedBy argument
        return isRoleRequest(attrRequest) &&
                ProvisioningPlan.ATT_IIQ_DETECTED_ROLES.equals(attrRequest.getName()) &&
                attrRequest.get(ProvisioningPlan.ARG_PERMITTED_BY) == null;
    }

    /**
     * Get a list of RoleAssignments that permit the given role
     * @param context SailPointContext
     * @param identity Identity being requested for
     * @param permittedRole Permitted role Bundle
     * @return Non-null list of RoleAssignment objects
     * @throws GeneralException
     */
    public static List<RoleAssignment> findAssignmentsPermittingRole(SailPointContext context, Identity identity, Bundle permittedRole)
            throws GeneralException {
        return findAssignmentsPermittingRole(context, identity, permittedRole, true);
    }

    /**
     * Get a list of RoleAssignments that permit the given role. Allow for excluding hard permits.
     *
     * @param context SailPointContext
     * @param identity Identity being requested for
     * @param permittedRole Permitted role Bundle
     * @return Non-null list of RoleAssignment objects
     * @throws GeneralException
     */
    public static List<RoleAssignment> findAssignmentsPermittingRole(SailPointContext context, Identity identity, Bundle permittedRole, boolean excludeHardPermits)
            throws GeneralException {

        List<RoleAssignment> permittingAssignments = new ArrayList<>();
        for (RoleAssignment assignment : Util.iterate(identity.getRoleAssignments())) {
            // filter out assignments that are negative or exclude hard permits if requested
            if (assignment.isNegative() || (excludeHardPermits && assignment.getPermittedRole(permittedRole) != null)) {
                continue;
            }

            Bundle assignedRole = assignment.getRoleObject(context);
            if (assignedRole == null) {
                continue;
            }

            if (Util.nullSafeContains(assignedRole.getFlattenedPermits().stream().collect(Collectors.toList()), permittedRole)) {
                permittingAssignments.add(assignment);
            }
        }

        return permittingAssignments;
    }

    /**
     * Constructs a new instance of LcmAccessRequestHelper.
     * @param context The context.
     * @param loggedInUser The logged in user.
     */
    public LcmAccessRequestHelper(SailPointContext context, Identity loggedInUser) {
        _context = context;
        _loggedInUser = loggedInUser;
    }

    /**
     * Sets the identity that is being requested for.
     * @param identity The identity.
     */
    public void setIdentity(Identity identity) {
        setIdentityIds(Arrays.asList(identity.getId()));
    }

    public void setQuickLink(String quickLinkName) {
        this._quickLinkName = quickLinkName;
    }

    /**
     * Sets the ids of the identities being requested for.
     * @param identityIds The ids.
     */
    public void setIdentityIds(List<String> identityIds) {
        _identityIds = identityIds;
    }

    /**
     * Sets the account requests to be compiled.
     * @param accountRequests The requests.
     */
    public void setAccountRequests(List<AccountRequest> accountRequests) {
        _accountRequests = accountRequests;
    }

    /**
     * Adds an id to the list of identities being requested for.
     * @param identityId
     */
    public void addIdentityId(String identityId) {
        if (_identityIds == null) {
            _identityIds = new ArrayList<String>();
        }

        _identityIds.add(identityId);
    }

    /**
     * Adds an account request to be compiled.
     * @param request The request.
     */
    public void addAccountRequest(AccountRequest request) {
        if (_accountRequests == null) {
            _accountRequests = new ArrayList<AccountRequest>();
        }

        _accountRequests.add(request);
    }

    /**
     * Set existing targets to be used for compilation. This reflects account selections made previously
     * in the LCM flow.
     * @param existingTargets List of ProvisioningTargets 
     */
    public void setExistingTargets(Map<String, List<ProvisioningTarget>> existingTargets) {
        _existingTargets = existingTargets;
    }

    /**
     * Clear provisioning targets from previous compilation.
     */
    public void clearProvisioningTargets() {
        _targetMap.clear();
    }

    /**
     * Adds ProvisioningTargets to the list mapped to the given identity ID
     * @param identityId ID of identity 
     * @param provisioningTargets List of ProvisioningTargets. Can be null. 
     */
    private void addProvisioningTargets(String identityId, List<ProvisioningTarget> provisioningTargets) {
        if (_targetMap == null) {
            _targetMap = new HashMap<String, List<ProvisioningTarget>>();
        }
        
        if (!_targetMap.containsKey(identityId)) {
            _targetMap.put(identityId, provisioningTargets);
        } else {
            if (provisioningTargets != null && _targetMap.get(identityId) != null) {
                _targetMap.get(identityId).addAll(provisioningTargets);
            } else if (_targetMap.get(identityId) == null) {
                _targetMap.put(identityId, provisioningTargets);
            }
        }
    }

    /**
     * Compiles the provisioning targets based on the configured
     * identity ids and account requests.
     * @throws GeneralException
     */
    public void compileProvisioningTargets() throws GeneralException {
        LcmAccessRequestHelper.populateAssignmentIds(_accountRequests);

        // Split account requests by object type
        List<AccountRequest> entitlementRequests = new ArrayList<AccountRequest>();
        List<AccountRequest> roleRequests = new ArrayList<AccountRequest>();
        for (AccountRequest request : Util.safeIterable(_accountRequests)) {
            if (isRoleRequest(request)) {
                roleRequests.add(request);
            } else {
                entitlementRequests.add(request);
            }
        }

        /* We want all the permitting roles at the front of the list 
         * so that compilation can reflect expected order of actions */
        Collections.sort(roleRequests, new Comparator<AccountRequest>() {
            @Override
            public int compare(AccountRequest o1, AccountRequest o2) {
                if (o1 == null && o2 == null) {
                    return 0;
                }

                if (o1 == null) {
                    return -1;
                }
                if (o2 == null) {
                    return 1;
                }

                boolean is1Permitted = !Util.isEmpty(o1.getAttributeRequests()) &&
                        !Util.isNullOrEmpty(o1.getAttributeRequests().get(0).getString(ProvisioningPlan.ARG_PERMITTED_BY));

                boolean is2Permitted = !Util.isEmpty(o2.getAttributeRequests()) &&
                        !Util.isNullOrEmpty(o2.getAttributeRequests().get(0).getString(ProvisioningPlan.ARG_PERMITTED_BY));


                if (is1Permitted && !is2Permitted) {
                    return 1;
                }
                if (!is1Permitted && is2Permitted) {
                    return -1;
                }

                return 0;
            }
        });
        
        for (String identityId : Util.safeIterable(_identityIds)) {
            Identity identity = getIdentity(identityId);
            if (identity != null) {
                
                // Compile any role requests
                compileRoleProvisioningTargets(identity, roleRequests);

                // "Compile" any entitlement requests 
                compileEntitlementProvisioningTargets(identity, entitlementRequests);
            }
        }
    }

    /**
     * Looks for any remove requests and validates that the user is
     * allowed to create remove requests based on the LCM population
     * configuration.
     *
     * @param requests The account requests.
     * @param isSelfService True if this is a self service request.
     * @param requestee Identity being requested for
     * @return True if all remove requests are valid.
     * @throws GeneralException
     */
    public boolean validateRemoveRequests(List<AccountRequest> requests, boolean isSelfService, Identity requestee)
        throws GeneralException {

        QuickLinkOptionsConfigService configService = new QuickLinkOptionsConfigService(_context);

        boolean canRemoveRoles = configService.isRequestControlOptionEnabledForRequestee(
                _loggedInUser,
                _quickLinkName,
                QuickLink.LCM_ACTION_REQUEST_ACCESS,
                Configuration.LCM_ALLOW_REQUEST_ROLES_REMOVE,
                isSelfService,
                requestee
        );

        boolean canRemoveEntitlements = configService.isRequestControlOptionEnabledForRequestee(
            _loggedInUser,
            _quickLinkName,
            QuickLink.LCM_ACTION_REQUEST_ACCESS,
            Configuration.LCM_ALLOW_REQUEST_ENTITLEMENTS_REMOVE,
            isSelfService,
            requestee
        );



        // bail early if removal is always ok
        if (canRemoveRoles && canRemoveEntitlements) {
            return true;
        }

        for (AccountRequest acctRequest : Util.iterate(requests)) {
            for (AttributeRequest attrRequest : Util.iterate(acctRequest.getAttributeRequests())) {
                if (ProvisioningPlan.Operation.Remove.equals(attrRequest.getOperation())) {
                    if ((isRoleRequest(attrRequest) && !canRemoveRoles) ||
                        (!isRoleRequest(attrRequest) && !canRemoveEntitlements)) {

                        return false;
                    }
                }
            }
        }

        return true;
    }

    /**
     * Compile a list of Role AccountRequests into ProvisioningTargets
     * @param identity Identity being targeted
     * @param roleRequests List of AccountRequests
     * @throws GeneralException
     */
    private void compileRoleProvisioningTargets(Identity identity, List<AccountRequest> roleRequests) throws GeneralException {
        if (Util.isEmpty(roleRequests)) {
            return;
        }
        
        Provisioner provisioner = new Provisioner(_context);
        provisioner.setArgument(PlanCompiler.ARG_LCM_USER, _loggedInUser.getName());
        provisioner.setArgument(PlanCompiler.ARG_LCM_QUICKLINK, _quickLinkName);

        ProvisioningPlan plan = new ProvisioningPlan();
        plan.setIdentity(identity);

        // Key: assignment ID, value: ProvisioningTarget with all AccountSelections
        Map<String, ProvisioningTarget> assignmentTargets = new HashMap<String, ProvisioningTarget>();
        for (AccountRequest request : Util.safeIterable(roleRequests)) {
            // if this is a direct permitted role request, which can only happen
            // when requesting for a single user, then add permittedBy argument
            if (!isBulkRequest() && isDirectPermittedRoleRequest(request)) {
                enhanceDirectPermittedRoleRequest(identity, request);
            }

            plan.add(request);
            findExistingRoleTargets(assignmentTargets, identity, request);
        }

        List<ProvisioningTarget> allTargets = new ArrayList<ProvisioningTarget>(assignmentTargets.values());
        if (!Util.isEmpty(allTargets)) {           
            plan.setProvisioningTargets(allTargets);
        }
        
        ProvisioningProject project = provisioner.compile(plan);

        addProvisioningTargets(identity.getId(), project.getProvisioningTargets());
    }

    /**
     * Compile a list of entitlement AccountRequests into ProvisioningTargets
     * @param identity Identity being targeted
     * @param entitlementRequests List of AccountRequests
     * @throws GeneralException
     */
    private void compileEntitlementProvisioningTargets(Identity identity, List<AccountRequest> entitlementRequests) throws GeneralException {
        // TODO: eventually this should just go through PlanCompiler too instead of fudging these targets
        List<ProvisioningTarget> provisioningTargets = new ArrayList<ProvisioningTarget>();
        IdentityService identityService = new IdentityService(_context);

        // Since it is an entitlement request, each AccountRequest should map to a ProvisioningTarget
        for (AccountRequest accountRequest : Util.safeIterable(entitlementRequests)) {
            ProvisioningTarget provisioningTarget = null;
            // If we already have a matching existing target, we can just use it as-is
            if (hasExistingTargets(identity)) {
                provisioningTarget = findMatchingEntitlementTarget(_existingTargets.get(identity.getId()), accountRequest);
            }

            if (provisioningTarget == null) {
                if (!(Util.size(accountRequest.getAttributeRequests()) == 1)) {
                    throw new GeneralException("Should be one attribute request for each account request for entitlements");
                }

                AttributeRequest attributeRequest = accountRequest.getAttributeRequests().get(0);
                Application application = accountRequest.getApplication(_context);
                provisioningTarget = new ProvisioningTarget(application, attributeRequest.getName(), (String)attributeRequest.getValue());
                provisioningTarget.setAssignmentId(attributeRequest.getAssignmentId());
                List<Link> links = identityService.getLinks(identity, application);

                boolean accountExists = Util.size(links) > 0;
                // Single account selection per account request
                AccountSelection accountSelection =
                        (accountExists) ? new AccountSelection(links) : new AccountSelection(application);

                boolean allowCreate = allowAdditionalAccount(application, Configuration.LCM_ALLOW_REQUEST_ENTITLEMENTS_ADDITIONAL_ACCOUNT_REQUESTS, identity);
                accountSelection.setAllowCreate(allowCreate);

                //If no account exists, mark as an implicit creation
                accountSelection.setImplicitCreate(!accountExists);

                String selectedNativeIdentity = null;
                // If account is specified in the request, or only one account exists and no creation allowed, 
                // select it automatically
                if (!Util.isNullOrEmpty(accountRequest.getNativeIdentity())) {
                    selectedNativeIdentity = accountRequest.getNativeIdentity();
                } else if (!allowCreate && Util.size(links) == 1) {
                    selectedNativeIdentity = links.get(0).getNativeIdentity();
                }
                accountSelection.setSelection(selectedNativeIdentity);

                provisioningTarget.addAccountSelection(accountSelection);
            }

            //We expect only one attributeAssignment
            AttributeRequest attributeRequest = accountRequest.getAttributeRequests().get(0);
            if (attributeRequest != null && Util.isNotNullOrEmpty(attributeRequest.getAssignmentId())
                    && provisioningTarget != null && Util.isNullOrEmpty(provisioningTarget.getAssignmentId())) {
                //Copy AttributeRequest assignmentId to provisioningTarget
                provisioningTarget.setAssignmentId(attributeRequest.getAssignmentId());
            }
            
            provisioningTargets.add(provisioningTarget);
        }
        
        addProvisioningTargets(identity.getId(), provisioningTargets); 
    }

    /**
     * Check if additional account creation is allowed on the given application considering
     * the LCM configuration and target identity
     * @throws GeneralException
     */
    private boolean allowAdditionalAccount(Application application, String requestControlKey, Identity identity) throws GeneralException {
        // optimizing here, do not compute hasRequestControl if application does not support additional accounts feature 
        if (!application.isSupportsAdditionalAccounts()) {
            return false;
        }
        
        QuickLinkOptionsConfigService qloConfigService = new QuickLinkOptionsConfigService(_context);
        boolean isSelfService = Util.nullSafeEq(_loggedInUser.getId(), identity.getId());

        boolean hasRequestControl = qloConfigService.isRequestControlOptionEnabled(
                _loggedInUser,
                _quickLinkName,
                QuickLink.LCM_ACTION_REQUEST_ACCESS,
                requestControlKey,
                isSelfService);
        
        return hasRequestControl;
    }

    /**
     * Determines if any of the compiled provisioning targets contains
     * account selections. This should be called after compileProvisioningTargets.
     * @return True if has selections, false otherwise.
     */
    public boolean hasAccountSelections() {
        for (List<ProvisioningTarget> targetList : _targetMap.values()) {
           if (hasAccountSelections(targetList)) {
               return true;
           }
        }

        return false;
    }

    /**
     * Determine if any of the compiled provisioning target for the given identity id 
     * contain necessary account selections. This should be called after compileProvisioningTargets.
     * @param identityId Identity ID
     * @return True if has selections, false otherwise.     
     */
    public boolean hasAccountSelections(String identityId) {
        List<ProvisioningTarget> targetList = _targetMap.get(identityId);
        return hasAccountSelections(targetList);
    }

    /**
     * Check the AccountSelections in the given ProvisioningTargets looking for 
     * any unanswered questions
     */
    private boolean hasAccountSelections(List<ProvisioningTarget> targetList) {
        for (ProvisioningTarget target : Util.safeIterable(targetList)) {
            for (AccountSelection selection : Util.safeIterable(target.getAccountSelections())) {
                if (!selection.isAnswered()) {
                    return true;
                }
            }
        }

        return false;
    }

    /**
     * Translates the compiled provisioning targets into a list of IdentityAccountSelection DTO
     * objects for REST responses.
     * @return List of {@link IdentityAccountSelection} objects.
     * @throws GeneralException
     */
    public List<IdentityAccountSelection> getIdentityAccountSelections() throws GeneralException {
       return getIdentityAccountSelections(false);
    }

    /**
     * Translates the compiled provisioning targets into a list of IdentityAccountSelection DTO
     * objects for REST responses.
     * @param includeAnswered If true, include account selections that have been answered
     * @return List of {@link IdentityAccountSelection} objects.
     * @throws GeneralException
     */
    public List<IdentityAccountSelection> getIdentityAccountSelections(boolean includeAnswered) throws GeneralException {
        List<IdentityAccountSelection> selectionsList = new ArrayList<IdentityAccountSelection>();

        Map<String,String> identityNamesById = this.getIdentityNamesById();

        for (Map.Entry<String,String> nameId : identityNamesById.entrySet()) {
            String identityId = nameId.getKey();
            String identityName = nameId.getValue();

            List<ProvisioningTarget> provTargets = _targetMap.get(identityId);

            // only send back if there are targets
            Map<String,List<IdentityAccountSelection.ProvisioningTarget>> convertedTargets = convertProvisioningTargets(identityId, provTargets, includeAnswered);
            if (!convertedTargets.isEmpty()) {
                List<IdentityAccountSelection.ProvisioningTarget> allTargets = new ArrayList<IdentityAccountSelection.ProvisioningTarget>();
                for (List<IdentityAccountSelection.ProvisioningTarget> currTargets : convertedTargets.values()) {
                    allTargets.addAll(currTargets);
                }
                selectionsList.add(new IdentityAccountSelection(identityId, identityName, allTargets));
            }
        }

        return selectionsList;
    }

    /**
     * Translates the compiled provisioning targets into a Map that maps access item ID to a
     * list of IdentityAccountSelection DTO objects for the item.  Unlike {@link #getIdentityAccountSelections()},
     * this handles when the provisioning targets span multiple items.
     *
     * @return A Map of item ID to a list of IdentityAccountSelection objects.
     * @throws GeneralException
     */
    public Map<String,List<IdentityAccountSelection>> getIdentityAccountSelectionsByItemId() throws GeneralException {
        Map<String,List<IdentityAccountSelection>> selectionsById = new HashMap<String,List<IdentityAccountSelection>>();

        Map<String,String> identityNamesById = this.getIdentityNamesById();

        // Iterate over the identities.
        for (Map.Entry<String,String> nameId : identityNamesById.entrySet()) {
            String identityId = nameId.getKey();
            String identityName = nameId.getValue();

            List<ProvisioningTarget> provTargets = _targetMap.get(identityId);

            // only send back if there are targets
            Map<String,List<IdentityAccountSelection.ProvisioningTarget>> convertedTargets = convertProvisioningTargets(identityId, provTargets, false);
            if (!convertedTargets.isEmpty()) {
                for (Map.Entry<String,List<IdentityAccountSelection.ProvisioningTarget>> entry : convertedTargets.entrySet()) {
                    String itemId = entry.getKey();
                    List<IdentityAccountSelection> selections = selectionsById.get(itemId);
                    if (null == selections) {
                        selections = new ArrayList<IdentityAccountSelection>();
                        selectionsById.put(itemId, selections);
                    }
                    selections.add(new IdentityAccountSelection(identityId, identityName, entry.getValue()));
                }
            }
        }

        return selectionsById;
    }

    /**
     * Return a map of identity names, keyed by ID.
     */
    private Map<String,String> getIdentityNamesById() throws GeneralException {
        Map<String,String> namesById = new HashMap<String,String>();

        SearchResultsIterator identityIterator =
                ObjectUtil.searchAcrossIds(_context, Identity.class, _identityIds, null, Arrays.asList("id", "name"));

        while (identityIterator.hasNext()) {
            Object[] identity = identityIterator.next();
            String identityId = (String)identity[0];
            String identityName = (String)identity[1];
            namesById.put(identityId, identityName);
        }

        return namesById;
    }

    /**
     * Gets the compiled provisioning targets for a specific identity.
     * @param identityId The identity id.
     * @return The provisioning targets.
     */
    public List<ProvisioningTarget> getProvisioningTargetsForIdentity(String identityId) {
        if (_targetMap == null || !_targetMap.containsKey(identityId)) {
            return new ArrayList<ProvisioningTarget>();
        }

        return _targetMap.get(identityId);
    }

    /**
     * Enhances a direct permitted role request with the permittedBy argument and assignmentId, as necessary. 
     * This is necessary for account selector rules to be properly run for the permitted role. 
     * @param identity The identity.
     * @param request The role request to check.
     */
    public void enhanceDirectPermittedRoleRequest(Identity identity, AccountRequest request) throws GeneralException {
        if (identity == null) {
            return;
        }

        // if we get here then we know we have one attribute request
        AttributeRequest attrRequest = request.getAttributeRequests().get(0);
        if (isRoleRequest(attrRequest)) {
            RoleAssignment assignment = null;
            if (!Util.isNullOrEmpty(attrRequest.getAssignmentId())) {
                assignment = identity.getRoleAssignmentById(attrRequest.getAssignmentId());
            } else {
                // If assignment ID isn't specified in the attribute request, look on the identity for a single matching assignment
                Bundle permittedRole = _context.getObjectByName(Bundle.class, (String)attrRequest.getValue());
                List<RoleAssignment> assignments = findAssignmentsPermittingRole(_context, identity, permittedRole);
                if (Util.size(assignments) == 1) {
                    assignment = assignments.get(0);
                    attrRequest.setAssignmentId(assignment.getAssignmentId());
                }
            }
            
            if (assignment != null) {
                attrRequest.put(ProvisioningPlan.ARG_PERMITTED_BY, assignment.getRoleName());
            }
        }
    }

    /**
     * Get copies of entitlement AccountRequest populated with account selections from compiled
     * provisioning targets. This should be called after compilation
     * @param identityId Id of identity to find targets
     * @return List of AccountRequests populated based on selections.
     * @throws GeneralException
     */
    //TODO: We really want real provisioning targets for account selections/additional accounts
    //      to be sent with request instead of messing manually with the master plan. For now plan compilation does
    //      not support it. 
    public List<AccountRequest> getEntitlementAccountRequestsWithSelections(String identityId)
            throws GeneralException {
        if (_targetMap == null) {
            throw new GeneralException("Must be compiled before adding provisioning targets");
        }

        List<ProvisioningTarget> targets = getProvisioningTargetsForIdentity(identityId);
        List<AccountRequest> newRequests = new ArrayList<AccountRequest>();
        for (AccountRequest request : Util.safeIterable(_accountRequests)) {
            if (!isRoleRequest(request)) {
                AccountRequest newAccountRequest = new AccountRequest(request);
                AccountSelection accountSelection = findAccountSelection(targets, newAccountRequest);
                if (accountSelection != null && accountSelection.isAnswered()) {
                    if (accountSelection.isDoCreate()) {
                        newAccountRequest.setOp(ProvisioningPlan.ObjectOperation.Create);
                        newAccountRequest.put(ProvisioningPlan.ARG_FORCE_NEW_ACCOUNT, true);
                        newAccountRequest.setNativeIdentity(null);
                    } else {
                        newAccountRequest.setNativeIdentity(accountSelection.getSelection());
                    }
                }

                newRequests.add(newAccountRequest);
            }
        }
        return newRequests;
    }

    /**
     * Determines if this is a bulk request.
     * @return True if bulk request, false otherwise.
     */
    private boolean isBulkRequest() {
        return Util.size(_identityIds) > 1;
    }

    /**
     * Converts the provisioning targets into a Map that maps item ID to a list of identity account selection
     * provisioning targets for UI consumption.
     *
     * @param identityId Id of identity to get assignments for
     * @param provTargets The provisioning targets.
     * @param includeAnswered If true, include account selections that have already been answered                   
     *
     * @return Map of item ID to a list of IdentityAccountSelection provisioning targets.
     * @throws GeneralException
     */
    private Map<String,List<IdentityAccountSelection.ProvisioningTarget>> convertProvisioningTargets(String identityId, List<ProvisioningTarget> provTargets, boolean includeAnswered)
            throws GeneralException {

        Map<String,List<IdentityAccountSelection.ProvisioningTarget>> targetsByItemId = new HashMap<String,List<IdentityAccountSelection.ProvisioningTarget>>();

        Identity identity = _context.getObjectById(Identity.class, identityId);

        CurrentAccessService currentAccessService = new CurrentAccessService(_context, identity);

        List<String> pending;

        for (ProvisioningTarget target : Util.safeIterable(provTargets)) {
            for (AccountSelection acctSelection : Util.safeIterable(target.getAccountSelections())) {
                // if selection is answered no need to ask
                if (!includeAnswered && acctSelection.isAnswered()) {
                    continue;
                }

                AccountRequest request = findAccountRequest(target, acctSelection);
                
                if (request != null) {

                    if (isRoleRequest(request)) {
                        pending = currentAccessService.getPendingRoleRequestAccounts(acctSelection.getOrigin(), acctSelection.getApplicationName(), acctSelection.getRoleName());
                    }
                    else {
                        pending = currentAccessService.getPendingEntitlementRequestAccounts(request);
                    }
    
                    String itemId = findItemId(request);
    
                    /* If permittedById is defined get the bundle and extract some info from it */
                    String permittedByName = request.getAttributeRequests().get(0).getString(ProvisioningPlan.ARG_PERMITTED_BY);
                    List<RoleAssignment> assignments = getRoleAssignments(identityId, permittedByName == null ? target.getRole() : permittedByName);
                    List<Link> links = getLinks(identityId, request);
                    IdentityAccountSelection.ProvisioningTarget provTarget =
                        new IdentityAccountSelection.ProvisioningTarget(target, acctSelection, assignments, links, pending);
    
                    List<IdentityAccountSelection.ProvisioningTarget> targetsForId = targetsByItemId.get(itemId);
                    if (null == targetsForId) {
                        targetsForId = new ArrayList<IdentityAccountSelection.ProvisioningTarget>();
                        targetsByItemId.put(itemId, targetsForId);
                    }
                    targetsForId.add(provTarget);
                }
            }
        }

        return targetsByItemId;
    }

    /**
     * Find the ID of the item for the given AccountRequest.
     *     
     * @param accountRequest AccountRequest    
     * @return The ID of the item for the given AccountRequest.
     *
     * @throws GeneralException  If the item could not be found.
     */
    private String findItemId(AccountRequest accountRequest) throws GeneralException {
        SailPointObject item;
        AttributeRequest attributeRequest = accountRequest.getAttributeRequests().get(0);
        
        if (isRoleRequest(accountRequest)) {
            // We already figured out these mappings when turning the AccessRequest
            // into a list of AccountRequests.  Would be nice to avoid these lookups.
            // This is going to happen rarely enough, that we won't worry about it for now.
            item = _context.getObjectByName(Bundle.class, (String)attributeRequest.getValue());
        }
        else {
            Application app = accountRequest.getApplication(_context);
            
            item = ManagedAttributer.get(_context, app, attributeRequest.getName(), (String)attributeRequest.getValue());
        }

        if (null == item) {
            throw new GeneralException("Could not find item for " + attributeRequest);
        }

        return item.getId();
    }

    /**
     * Gets existing account assignments
     * @param identityId The identity that may have assignments
     * @param roleName The role that the assignments are for
     * @return List of existing assignments, or null
     * @throws GeneralException If unable to get Identity
     */
    private List<RoleAssignment> getRoleAssignments(String identityId, String roleName) throws GeneralException {
        if (roleName == null) {
            return null;
        }

        Identity identity = _context.getObjectById(Identity.class, identityId);

        // only check active role assignments, i.e. those that are not negative
        return identity.getActiveRoleAssignments(roleName);
    }

    /**
     * Get existing links for the entitlement account request
     * @param identityId Identity ID 
     * @param accountRequest AccountRequest
     * @return List of links, or null
     * @throws GeneralException
     */
    private List<Link> getLinks(String identityId, AccountRequest accountRequest) throws GeneralException {
        if (isRoleRequest(accountRequest)) {
            return null;
        }

        Identity identity = _context.getObjectById(Identity.class, identityId);
        return new IdentityService(_context).getLinks(identity, accountRequest.getApplication(_context), accountRequest.getInstance());
    }

    /**
     * Populates assignment ids on the requests. We have to link together
     * requests for permitted roles with the assignable role.
     */
    public static void populateAssignmentIds(List<AccountRequest> accountRequests) {
        for (AccountRequest request : Util.safeIterable(accountRequests)) {
            for (AttributeRequest attrRequest : Util.safeIterable(request.getAttributeRequests())) {
                // skip direct permitted role requests, these will be handled on an
                // Identity basis later
                if (Util.isNullOrEmpty(attrRequest.getAssignmentId())) {
                    if (isRoleRequest(attrRequest) &&
                            !isDirectPermittedRoleRequest(request)) {
                        String permittedBy = attrRequest.getString(ProvisioningPlan.ARG_PERMITTED_BY);

                        // either find the assignment id of the permitted by role or create one
                        String assignmentId = Util.isNullOrEmpty(permittedBy) ?
                                Util.uuid() : findPermittedByAssignmentId(accountRequests, permittedBy);

                        attrRequest.setAssignmentId(assignmentId);
                    } else if (!isRoleRequest(attrRequest)) {
                        //EntitlementRequest needs assignmentId as well
                        attrRequest.setAssignmentId(Util.uuid());
                    }
                }
            }
        }
    }

    /**
     * Finds the assignment id of the permitted by role name.
     * @param roleName The role name.
     * @return The assignment id.
     */
    private static String findPermittedByAssignmentId(
            List<AccountRequest> accountRequests, String roleName) {
        for (AccountRequest request : Util.safeIterable(accountRequests)) {
            for (AttributeRequest attrRequest : Util.safeIterable(request.getAttributeRequests())) {
                if (roleName.equals(attrRequest.getValue())) {
                    // if an id is not set yet then set it
                    if (Util.isNullOrEmpty(attrRequest.getAssignmentId())) {
                        attrRequest.setAssignmentId(Util.uuid());
                    }

                    return attrRequest.getAssignmentId();
                }
            }
        }

        return null;
    }

    /**
     * Gets the identity with the specified id.
     * @param identityId The identity id.
     * @return The identity.
     * @throws GeneralException
     */
    private Identity getIdentity(String identityId) throws GeneralException {
        return _context.getObjectById(Identity.class, identityId);
    }
    
    public static boolean isRoleRequest(AccountRequest accountRequest) {
        boolean isRole = false;
        if (ProvisioningPlan.APP_IIQ.equals(accountRequest.getApplication()) && Util.size(accountRequest.getAttributeRequests()) > 0) {
            AttributeRequest attributeRequest = accountRequest.getAttributeRequests().get(0);
            isRole = isRoleRequest(attributeRequest);
        }
        
        return isRole;
    }

    /**
     * Helper to get the role name from an account request. 
     * @param accountRequest AccountRequest with role request
     * @return Role name, or null if not a role request
     */
    public static String getRoleName(AccountRequest accountRequest) {
        String roleName = null;
        if (isRoleRequest(accountRequest)) {
            AttributeRequest attributeRequest = accountRequest.getAttributeRequests().get(0);
            roleName = (String)attributeRequest.getValue();
        }
        return roleName;
    }
    
    public static boolean isRoleRequest(AttributeRequest attributeRequest) {
        return ProvisioningPlan.ATT_IIQ_ASSIGNED_ROLES.equals(attributeRequest.getName()) ||
                ProvisioningPlan.ATT_IIQ_DETECTED_ROLES.equals(attributeRequest.getName());
    }

    private boolean hasExistingTargets(Identity identity) {
        return _existingTargets != null && identity != null && _existingTargets.containsKey(identity.getId());
    }

    /**
     * Given the passed Identity and AccountRequest, find matching existing targets and place them 
     * in the given map, keyed by assignment id.  If assignment id applies to more than one role (i.e.
     * permitted role(s) with assigned role) then merge their ProvisioningTarget into a single one with all
     * the account selections.
     */
    private void findExistingRoleTargets(Map<String, ProvisioningTarget> targets, Identity identity, AccountRequest accountRequest) {
        if (!hasExistingTargets(identity)) {
            return;
        }

        Map<String, String> roleAssignmentMap = new HashMap<String, String>();
        for (AttributeRequest request : accountRequest.getAttributeRequests()) {
            roleAssignmentMap.put((String)request.getValue(), request.getAssignmentId());
        }

        for (ProvisioningTarget target: _existingTargets.get(identity.getId()))  {
            if (target.getRole() != null && roleAssignmentMap.keySet().contains(target.getRole())) {
                String assignmentId = roleAssignmentMap.get(target.getRole());
                if (targets.containsKey(assignmentId)) {
                    targets.get(assignmentId).addAccountSelections(target.getAccountSelections());
                } else {
                    ProvisioningTarget newTarget = new ProvisioningTarget(target);
                    newTarget.setAssignmentId(assignmentId);
                    targets.put(assignmentId, newTarget);
                }
            }
        }
    }

    private ProvisioningTarget findMatchingEntitlementTarget(List<ProvisioningTarget> targets, AccountRequest accountRequest) throws GeneralException {
        if (!(Util.size(accountRequest.getAttributeRequests()) == 1)) {
            throw new GeneralException("Should be one attribute request for each account request for entitlements");
        }
        AttributeRequest attributeRequest = accountRequest.getAttributeRequests().get(0);
        for (ProvisioningTarget target : Util.safeIterable(targets)) {
            if (Util.nullSafeEq(target.getApplication(), accountRequest.getApplication()) &&
                    Util.nullSafeEq(target.getAttribute(), attributeRequest.getName()) &&
                    Util.nullSafeEq(target.getValue(), attributeRequest.getValue())) {
                return target;
            }
        }
        return null;
    }

    private AccountSelection findAccountSelection(List<ProvisioningTarget> targets, AccountRequest accountRequest)
            throws GeneralException {
        AccountSelection accountSelection = null;

        ProvisioningTarget matchingTarget = findMatchingEntitlementTarget(targets, accountRequest);
        if (matchingTarget != null) {
            if (!(Util.size(matchingTarget.getAccountSelections()) == 1)) {
                throw new GeneralException("Should be one account selection for entitlements");
            }
            accountSelection = matchingTarget.getAccountSelections().get(0);
        }
        return accountSelection;
    }

    private AccountRequest findAccountRequest(ProvisioningTarget target, AccountSelection accountSelection) {
        AccountRequest accountRequest;
        if (target.getRole() != null) {
            accountRequest = findRoleAccountRequest(target, accountSelection);
        } else {
            accountRequest = findEntitlementAccountRequest(target);
        }
        return accountRequest;
    }

    private AccountRequest findRoleAccountRequest(ProvisioningTarget target, AccountSelection accountSelection) {
        AccountRequest targetRoleRequest = null;
        AccountRequest accountSelectionRoleRequest = null;

        for (AccountRequest accountRequest: Util.safeIterable(_accountRequests)) {
            if (isRoleRequest(accountRequest)) {
                AttributeRequest attributeRequest = accountRequest.getAttributeRequests().get(0);
                if (attributeRequest != null) {
                    if (!Util.isNullOrEmpty(accountSelection.getOrigin()) &&
                            Util.nullSafeEq(attributeRequest.getValue(), accountSelection.getOrigin())) {
                        accountSelectionRoleRequest = accountRequest;
                    } else if (Util.nullSafeEq(attributeRequest.getValue(), target.getRole())) {
                        targetRoleRequest = accountRequest;
                    }
                }
            }
        }
        return (accountSelectionRoleRequest != null) ? accountSelectionRoleRequest : targetRoleRequest;
    }

    private AccountRequest findEntitlementAccountRequest(ProvisioningTarget target) {
        for (AccountRequest accountRequest: Util.safeIterable(_accountRequests)) {
            if (!isRoleRequest(accountRequest)) {
                AttributeRequest attributeRequest = accountRequest.getAttributeRequests().get(0);
                if (attributeRequest != null &&
                        (Util.nullSafeEq(accountRequest.getApplicationName(), target.getApplication()) &&
                                Util.nullSafeEq(attributeRequest.getName(), target.getAttribute()) &&
                                Util.nullSafeEq(attributeRequest.getValue(), target.getValue()))) {
                    return accountRequest;
                }
            }
        }
        return null;
    }
}
