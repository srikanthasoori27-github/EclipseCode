/* (c) Copyright 2008 SailPoint Technologies, Inc., All Rights Reserved. */

/**
 * NOTE: This hasn't been used in years consider removing it...
 * 
 * Implementation of PersistenceManager that uses the file system.
 * Useful for devlopment and unit testing without needing a full
 * blown database.
 *
 * There is no caching here, it is expected to be used with a small
 * number of objects, accessed infrequently.
 *
 * Uses the XML format generated by SailPointObject.
 */

package sailpoint.persistence;

import java.io.File;
import java.io.FileFilter;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;

import sailpoint.object.SailPointObject;
import sailpoint.tools.GeneralException;
import sailpoint.tools.Util;
import sailpoint.tools.xml.XMLReferenceResolver;

public class FilePersistenceManager extends AbstractPersistenceManager {

    //////////////////////////////////////////////////////////////////////
    //
    // Fields
    // 
    //////////////////////////////////////////////////////////////////////

    /**
     * The base directory of the repository.
     * TODO: It would be cleaner if we had a seperate directory
     * for each class.
     */
    String mRootDirectory;

    /**
     * File handle to the root directory.
     */
    File mRoot;

    //////////////////////////////////////////////////////////////////////
    //
    // Constructors
    // 
    //////////////////////////////////////////////////////////////////////

    public FilePersistenceManager() {
        setRootDirectory(".");
    }

    public void setRootDirectory(String root) {
        File f = new File(root);
        if (f.isDirectory()) {
            mRootDirectory = root;
            mRoot = new File(mRootDirectory);
        }
    }

    //////////////////////////////////////////////////////////////////////
    //
    // PersistenceManager
    // 
    //////////////////////////////////////////////////////////////////////

    /**
     * Format the full path to an object.
     */
    public String getObjectPath(Class cls, String name) {

        return mRootDirectory + "/" + cls.getSimpleName() + "-" + name;
    }

    /**
     * Format the full path to an object.
     */
    public String getObjectPath(SailPointObject obj) {

        return getObjectPath(obj.getClass(), obj.getName());
    }

    /**
     * Retrieve an object by name.
     */
    public <T extends SailPointObject> T getObjectByName(Class<T> cls, String name)
        throws GeneralException {

        SailPointObject obj = null;
        String path = getObjectPath(cls, name);
        File f = new File(path);
        if (f.isFile()) {
            String xml = Util.readFile(f);
            // NOTE: suporting reference resolution by passing XMLReferenceResolver to parse xml function
            // XMLReferenceResolver interface which contain method getReferencedObject to read reference
            obj = (SailPointObject)SailPointObject.parseXml(new FileReferenceResolver(), xml);
        }
        return cls.cast(obj);
    }
    
    private class FileReferenceResolver implements XMLReferenceResolver 
    {

        @Override
        public Object getReferencedObject(String className, String id,
                String name) throws GeneralException {

            if (className == null || className.length() == 0)
                throw new GeneralException("Missing class name");

            if (className.indexOf(".") < 0)
                className = "sailpoint.object." + className;

            SailPointObject obj = null;
            Class cls = getClass(className);

            if (id != null) {
                obj = getObjectById(cls, id);
            }

            if (obj == null && name != null) {
                obj = getObjectByName(cls, name);
            }
            return obj;
        }
        /**
         * Utility to resolve a class, throwing a common exception.
         */
        public Class getClass(String cls) throws GeneralException {
            Class c = null;
            try {
                c = Class.forName(cls);
            }
            catch (ClassNotFoundException e) {
                throw new GeneralException(e);
            }
            return c;
        }
    }
    public <T extends SailPointObject> T getObject(Class<T> cls, String name)
        throws GeneralException {

        return getObjectByName(cls, name);
    }

    public <T extends SailPointObject> T lockObjectById(Class<T> cls, String id,
                                                    Map<String,Object> options)
        throws GeneralException {

        return getObjectByName(cls, id);
    }

    public <T extends SailPointObject> T lockObjectByName(Class<T> cls, String name,
                                                          Map<String,Object> options)
        throws GeneralException {

        return getObjectByName(cls, name);
    }

    public <T extends SailPointObject> void unlockObject(T object)
        throws GeneralException {
    }

    /**
     * Save an object in the persistent store.
     */
    public void saveObject(SailPointObject obj) throws GeneralException {

        if (obj != null && obj.getName() != null) {
            String path = getObjectPath(obj);
            String xml = obj.toXml();
            Util.writeFile(path, xml);
        }
    }

    public void importObject(SailPointObject obj) throws GeneralException {

        // technically it is incorrect to treat save and import the same
        // save shoudl be checking for existing objects with the same name
        saveObject(obj);
    }

    /**
     * Remove an object from the persistent store.
     */
    public void removeObject(SailPointObject obj) throws GeneralException {

        String path = getObjectPath(obj.getClass(), obj.getName());
        File f = new File(path);
        if (f.isFile())
            f.delete();
    }

    /**
     * Return all objects of a given class.
     */
    public <T extends SailPointObject> List<T> getObjects(Class<T> cls) 
        throws GeneralException {

        List objects = null;

        final String cname = cls.getSimpleName();
		File files[] = mRoot.listFiles(new FileFilter() {
                public boolean accept(File pathname) {
                    return (pathname.isFile() &&
                            pathname.getName().startsWith(cname));
                }
            });

        if (files != null) {
            objects = new ArrayList(files.length);
            for (int i = 0 ; i < files.length ; i++) {
                // hmm, since this is just a testing hack, be tolerant
                // of corrupted files
                try {
                    String xml = Util.readFile(files[i]);
                    Object obj = SailPointObject.parseXml(null, xml);
                    objects.add(obj);
                }
                catch (Exception e) {
                    // just ignore this one
                }
            }
        }

		return objects;
    }


    //////////////////////////////////////////////////////////////////////  
    //
    // Test - move to a Junit someday if this lives that long...
    //
    //////////////////////////////////////////////////////////////////////  

    public static void main(String[] args) {

        try {
            FilePersistenceManager fm = new FilePersistenceManager();
            fm.setRootDirectory("c:/temp");

            // don't have this class any more!
            /*
            AuditRecord ar = new AuditRecord();
            // hmm, need to relax the name requirement here!!
            ar.setName("1");
            ar.setSession("123456");
            ar.setIpAddress(0);
            ar.setOp("C");
            ar.setUrl("http://www.chase.com");
            ar.setFirefox(1000);
            ar.setVnc(2500);
            fm.saveObject(ar);
            */

            // Eclipse is saying this is an ambiguous method,
            // not sure what the deal is
            //AuditRecord ar2 = (AuditRecord)fm.getObject(AuditRecord.class, "1");
            // need a deep equals...
        }
        catch (Throwable t) {
            System.out.println(t);
        }
    }
}
