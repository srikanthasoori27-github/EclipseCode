/* (c) Copyright 2008 SailPoint Technologies, Inc., All Rights Reserved. */

package sailpoint.task;

import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
import java.util.Locale;
import java.util.Map;

import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;

import sailpoint.api.CertificationBuilder;
import sailpoint.api.CertificationBuilderFactory;
import sailpoint.api.CertificationContext;
import sailpoint.api.CertificationScheduler;
import sailpoint.api.Certificationer;
import sailpoint.api.Meter;
import sailpoint.api.ObjectUtil;
import sailpoint.api.SailPointContext;
import sailpoint.certification.IdentityCertificationStarter;
import sailpoint.object.Attributes;
import sailpoint.object.Certification;
import sailpoint.object.Certification.Type;
import sailpoint.object.CertificationDefinition;
import sailpoint.object.CertificationGroup;
import sailpoint.object.CertificationSchedule;
import sailpoint.object.Identity;
import sailpoint.object.TaskResult;
import sailpoint.object.TaskSchedule;
import sailpoint.tools.GeneralException;
import sailpoint.tools.Internationalizer;
import sailpoint.tools.Message;
import sailpoint.tools.Util;
import sailpoint.web.messages.MessageKeys;


/**
 * A task executor that generates scheduled certifications.
 *
 * @author Peter Holcomb
 * @author Kelly Grizzle
 */
public class CertificationExecutor extends AbstractTaskExecutor {

    private static final Log log = LogFactory.getLog(CertificationExecutor.class);

    ////////////////////////////////////////////////////////////////////////////
    //
    // CONSTANTS
    //
    ////////////////////////////////////////////////////////////////////////////

    /**
     * The type of certification.

     * @ignore
     * TQM: Don't see this being used anywhere.
     */
    @Deprecated
    public static final String ARG_CERTIFICATION_TYPE = "certificationType";

    /**
     * True if profiling enabled
     */
    public static final String ARG_PROFILE = "profile";

    public static final String RET_TOTAL = "total";
    private static final String RET_TYPE = "type";
    private static final String RET_EMAILS_SUPPRESSED = "emailsSuppressed";
    private static final String RET_ACTIVE_PERIOD_DURATION_AMOUNT =
        "activePeriodDurationAmount";
    private static final String RET_ACTIVE_PERIOD_DURATION_SCALE =
        "activePeriodDurationScale";
    private static final String RET_CHALLENGE_PERIOD_DURATION_AMOUNT =
        "challengePeriodDurationAmount";
    private static final String RET_CHALLENGE_PERIOD_DURATION_SCALE =
        "challengePeriodDurationScale";
    private static final String RET_REMEDIATION_PERIOD_DURATION_AMOUNT =
        "remediationPeriodDurationAmount";
    private static final String RET_REMEDIATION_PERIOD_DURATION_SCALE =
        "remediationPeriodDurationScale";

    /**
     * List of certification group IDs generated by this task.
     * This applies to certification schedule tasks only.
     */
    public static final String RET_CERT_GROUP_IDS =
        "resultingCertGroupIds";
    
    
    ////////////////////////////////////////////////////////////////////////////
    //
    // FIELDS
    //
    ////////////////////////////////////////////////////////////////////////////
    
    /**
     * Set by the terminate method to indiciate that we should stop
     * when convenient.
     */
    private boolean terminate;

    private SailPointContext context;
    private Attributes<String,Object> args;
    private TaskSchedule schedule;
    private TaskResult result;
    private TaskMonitor monitor;

    private CertificationDefinition definition;
    private Identity requestor;

    private boolean profile;

    IdentityCertificationStarter _targetedStarter;
    
    ////////////////////////////////////////////////////////////////////////////
    //
    // CONSTRUCTORS
    //
    ////////////////////////////////////////////////////////////////////////////
    
    /**
     * Default constructor.
     */
    public CertificationExecutor() {}

    
    ////////////////////////////////////////////////////////////////////////////
    //
    // EXECUTOR IMPLEMENTATION
    //
    ////////////////////////////////////////////////////////////////////////////
    
    /* (non-Javadoc)
     * @see sailpoint.object.TaskExecutor#terminate()
     */
    public boolean terminate()
    {
        this.terminate = true;

        // pass along if this happens to be running synchronously
        if (_targetedStarter != null)
            _targetedStarter.terminate();
        
        return true;
    }

    /* (non-Javadoc)
     * @see sailpoint.object.TaskExecutor#execute(sailpoint.object.SailPointContext, sailpoint.object.TaskSchedule, sailpoint.object.Attributes)
     */
    public void execute(SailPointContext context, TaskSchedule sched,
                        TaskResult result,
                        Attributes<String, Object> args) throws Exception {

        log.debug("Executing Certification");

        CertificationBuilder builder = null;

        this.terminate = false;
        this.context = context;
        this.args = args;
        this.schedule = sched;
        this.result = result;

        Message errorMessage = null;

        long startTime = System.currentTimeMillis();
        final String MeterExecute = "CertificationExecutor: execute";
        Meter.enter(MeterExecute);
        Meter.reset();
        
        try {

            this.monitor = new TaskMonitor(context, this.result);
            
            if (null != this.schedule) {
                String launcher = this.schedule.getLauncher();
                if (null != launcher) {
                    this.requestor =
                        this.context.getObjectByName(Identity.class, launcher);
                }
            }
            
            parseArguments(args);

            // Continuous certs are deprectated so we will not allow generating any from lingering definitions
            // or schedules.
            if (this.definition.isContinuous()) {
                throw new GeneralException(MessageKeys.CERTIFICATION_ERROR_CONTINUOUS);
            }

            // Like partitioned manager certs, Focused certs bypass the old
            // builder logic
            if (handleTargetedCert()) {
                return;
            }
            
            // If partitioning is enabled handle it via the delegate.
            if (handleManagerCert()) {
                if (log.isInfoEnabled()) {
                    log.info("Manager Cert Handled Via Partitioning.");
                }
                return;
            }

            Certificationer c = new Certificationer(this.context);

            Meter.enter(120, "CertificationExecutor: Executing Certification");

            Meter.enter(121, "CertificationExecutor: Create certification builder");
            builder = new CertificationBuilderFactory(this.context).getBuilder(this.definition, this.schedule);
            builder.init();
            Meter.exit(121);

            updateProgress("Calculating certifications to generate.");
            Meter.enter(122, "CertificationExecutor: Create certification contexts");
            Iterator<CertificationContext> certCtxs = builder.getContexts();
            Meter.exit(122);

            int totalCertCount = 0; // Total number of certs created, including sub-certs
            if (null != certCtxs && certCtxs.hasNext()) {
                while (certCtxs.hasNext()) {

                    // TODO: Do we need this?  This is here b/c we're reconnecting
                    // after we save the cert.
                    c.init(context);

                    Meter.enter(123, "CertificationExecutor: Retrieve certification context");
                    CertificationContext certCtx = certCtxs.next();
                    Meter.exit(123);

                    if (this.terminate) {
                        this.reattachResult();
                        result.setTerminated(true);
                        result.addMessage(new Message(Message.Type.Warn,
                                MessageKeys.CERT_GEN_TERMINATED));
                        break;
                    }

                    updateProgress("Generating certification '" + certCtx.generateName() + "'");
                    
                    Meter.enter(124, "CertificationExecutor: Render certification");
                    Certification cert = c.generateCertification(requestor, certCtx);
                    Meter.exit(124);
                    if (cert == null){
                        this.reattachResult();

                        result.addMessage(new Message(Message.Type.Warn,
                                MessageKeys.NOTHING_TO_CERTIFY, certCtx.generateName(), builder.getEntityName(true)));                   
                    }
                    else {
                        updateProgress("Saving certification '" + cert.getShortName() + "'");

                        Meter.enter(125, "CertificationExecutor: Start certification");
                        Certificationer.CertificationStartResults startResults = c.start(cert);
                        totalCertCount += startResults.getCertificationCount();
                        Meter.exit(125);

                        // Reattach in case the session gets cleared.
                        Meter.enter(126, "CertificationExecutor: Reconnect");
                        cert = ObjectUtil.reattach(this.context, cert);

                        context.reconnect();
                        Meter.exit(126);
                    }
                }
            }else{
                this.reattachResult();
                result.addMessage(new Message(Message.Type.Warn,
                        MessageKeys.WARN_NOTHING_TO_CERTIFY, builder.getEntityName(true)));
            }

            // This will reattach the result.
            log.debug("Finished generating certifications. Count: " + totalCertCount);
            updateProgress("Finished generating certifications.");

            Meter.enter(127, "CertificationExecutor: Post-Generation Tasks");
            result.setAttributes(getResults(builder));
            result.setAttribute(RET_TYPE, Internationalizer.getMessage(definition.getType().getMessageKey(),
                    Locale.getDefault()));
            result.setAttribute(RET_EMAILS_SUPPRESSED, c.getEmailsSuppressed());
            result.setAttribute(RET_TOTAL, totalCertCount);

            addCertificationDefinitionResults(result);

            if (builder.getCertificationGroups() != null){
                List<String> resultingCertGroups = new ArrayList<String>();
                for(CertificationGroup group : builder.getCertificationGroups()){
                    resultingCertGroups.add(group.getId());
                }
                result.setAttribute(RET_CERT_GROUP_IDS, Util.listToCsv(resultingCertGroups));
            }
            
            // Add any errors or warnings to the result.
            if (c.getErrors() != null)
                result.addMessages(c.getErrors());
            if (c.getWarnings() != null)
                result.addMessages(c.getWarnings());

            if (!builder.getWarnings().isEmpty()){
                for (Message warning : builder.getWarnings())
                    result.addMessage(warning);
            }
            Meter.exit(127);
          
            Meter.exit(120);

            if (this.profile) {
                Meter.report();
            }
        } catch (Throwable t)
        {
            errorMessage = new Message(Message.Type.Error ,MessageKeys.ERR_EXCEPTION, t);
            // jsl - JobAdapter will do this now too
            log.error(errorMessage.getMessage(), t);
            result.addMessage(errorMessage);
        } finally{
            // Set the status of any certification groups and refresh their statistics.
            // Also collect any errors and warnings from the task
            Meter.enter(128, "CertificationExecutor: Update Certification Groups");
            if (builder != null){
                List<Message> msgs = new ArrayList<Message>();
                 if (result != null){
                    if (result.getErrors() != null)
                        msgs.addAll(result.getErrors());
                    if (result.getWarnings() != null)
                        msgs.addAll(result.getWarnings());
                    if (errorMessage != null)
                        msgs.add(errorMessage);
                    builder.finalize(errorMessage == null, msgs);
                }
            }
            Meter.exit(128);

            Meter.exit(MeterExecute);

            // store the profile in the result so we can analyize it later
            if (this.profile) {
                List<Map<String,String>> report = Meter.render();
                result.put("profile", report);
            }

            // unconditionally store this since it's such a pita to get the profile flag on
            long endTime = System.currentTimeMillis();
            result.put("elapsedTime", Util.ltoa(endTime - startTime));
        }
    }

    // Call partitioned task executor for manager certs.
    // This will return true if handled otherwise
    // if processing needs to continue it will return false.
    private boolean handleManagerCert() throws Exception {

        boolean handled = false;
        
        if (definition.getType() == Type.Manager && definition.isEnablePartitioning()) {
            PartitionedManagerCertificationTaskExecutor executorDelegate = new PartitionedManagerCertificationTaskExecutor();
            executorDelegate.execute(context, schedule, result, args);
            handled = true;
        }
        
        return handled;
    }

    /**
     * Check for the new Focused cert type and redirect to the new cert builder.
     *
     * TODO: If we do target id calculation up front, think about having that
     * be terminatable.  If we stuffed that in another Request and finished early
     * we wouldn't have to.
     */
    private boolean handleTargetedCert() throws Exception {

        boolean handled = false;

        // do we really need to continue support for the old enum?
        if (definition.getType() == Type.Focused) {
            _targetedStarter = new IdentityCertificationStarter(this.context, this.schedule, this.result, this.args);
            _targetedStarter.execute();
            handled = true;
        }
        return handled;
    }

    private void updateProgress(String progress) throws GeneralException {

        reattachResult();
        this.monitor.reattach(this.result);
        this.monitor.updateProgress(progress);
    }
    
    private TaskResult reattachResult() throws GeneralException {
        
        if (null != this.result.getId()) {
            this.result = this.context.getObjectById(TaskResult.class, this.result.getId());
        }

        return this.result;
    }
    
    /**
     * Parse the common certification arguments from the given input.
     *
     * @param  args  The arguments to parse.
     */
    private void parseArguments(Attributes<String, Object> args)
        throws GeneralException {

        // This is usually on the definition.
        CertificationScheduler scheduler =
            new CertificationScheduler(this.context);

        try {
            this.definition = scheduler.getCertificationDefinition(this.schedule);
        }
        catch (IllegalArgumentException e) {
            // This allows having the definition ID specified in the
            // certification definition.  We're supporting this only for the
            // scale data and demo data setup where we want to launch a task
            // immediately to create the certification without having to use
            // a schedule.
            if (null != args) {
              String defId =
                  args.getString(CertificationSchedule.ARG_CERTIFICATION_DEFINITION_ID);
              if (null != defId) {
                  //TODO: This was named ID, but we now set it as name?! -rap
                  this.definition = this.context.getObjectByName(CertificationDefinition.class, defId);
              }
            }

            if (null == this.definition) {
              throw e;
            }

            if(definition.getCertificationNameTemplate() == null){
                definition.setCertificationNameTemplate(definition.getName());
            }

            if (definition.getCertificationOwner() == null){
                definition.setCertificationOwner(definition.getOwner());
            }
        }

        this.profile = args.getBoolean(ARG_PROFILE, false);

        // jsl - since this is impossible to set with "Run now" allow it to be
        // enabled with a naming convention
        // I also added this to CertificationDefinition, but we're not using it
        // now that we have the naming convention
        if (!this.profile) {
            String name = definition.getCertificationNameTemplate();
            this.profile = (name != null && name.startsWith("Profile"));
        }
        
    }

    /**
     * Get results from the builder and put them in a format that can be added
     * to the TaskResult.
     */
    Attributes<String,Object> getResults(CertificationBuilder builder) {

        Attributes<String,Object> attrs = new Attributes<String,Object>();
        Map<String,Object> results = builder.getResults();
        if (null != results) {
            for (Map.Entry<String,Object> entry : results.entrySet()) {
                attrs.put(entry.getKey(), entry.getValue().toString());
            }
        }
        return attrs;
    }

    /**
     * Add interesting parameters about the certification definition to the
     * given task result.
     */
    private void addCertificationDefinitionResults(TaskResult result) {

        result.setAttribute(RET_ACTIVE_PERIOD_DURATION_AMOUNT,
                            String.valueOf(this.definition.getActivePeriodDurationAmount()));
        if (this.definition.getActivePeriodDurationScale() != null) {
            result.setAttribute(RET_ACTIVE_PERIOD_DURATION_SCALE,
                                String.valueOf(this.definition.getActivePeriodDurationScale().getMessageKey()));
        }
        
        if (this.definition.isChallengePeriodEnabled()) {
            result.setAttribute(RET_CHALLENGE_PERIOD_DURATION_AMOUNT,
                                String.valueOf(this.definition.getChallengePeriodDurationAmount()));
            if (this.definition.getChallengePeriodDurationScale() != null) {
                result.setAttribute(RET_CHALLENGE_PERIOD_DURATION_SCALE,
                                    String.valueOf(this.definition.getChallengePeriodDurationScale().getMessageKey()));
            }
        }
        
        if (this.definition.isRemediationPeriodEnabled()) {
            result.setAttribute(RET_REMEDIATION_PERIOD_DURATION_AMOUNT,
                                String.valueOf(this.definition.getRemediationPeriodDurationAmount()));
            if (this.definition.getRemediationPeriodDurationScale() != null) {
                result.setAttribute(RET_REMEDIATION_PERIOD_DURATION_SCALE,
                                    String.valueOf(this.definition.getRemediationPeriodDurationScale().getMessageKey()));
            }
        }
    }
    

}
