<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE Rule PUBLIC "sailpoint.dtd" "sailpoint.dtd">
<Rule language="beanshell" name="ELE-Blackline-After-Operation-Rule" type="WebServiceAfterOperationRule">
  <Description>This rule is used by the  Web Services connector to update parsed resource object 
and save connectorStatemap values.Create List of Objects  which will later converted to Resource object and save connectorStatemap values to the application object permanently. The returned map will hold key 'data' for resource object list and key 'connectorStateMap' for udpated attribute that need to be saved in the application.</Description>
  <Signature returnType="Object">
    <Inputs>
      <Argument name="log">
        <Description>
          The log object associated with the SailPointContext.
        </Description>
      </Argument>
      <Argument name="context">
        <Description>
          A sailpoint.api.SailPointContext object that can be used to query the database if necessary.
        </Description>
      </Argument>
      <Argument name="application">
        <Description>The application whose data file is being processed.</Description>
      </Argument>
      <Argument name="requestEndPoint">
        <Description>The current request information contain header, body ,response object</Description>
      </Argument>
      <Argument name="processedResponseObject">
        <Description>Response Object processed by the Web services connector</Description>
      </Argument>
      <Argument name="rawResponseObject">
        <Description>Response Object returned from the end system</Description>
      </Argument>
      <Argument name="restClient">
        <Description>REST Client Object</Description>
      </Argument>
    </Inputs>
    <Returns>
      <Argument name="Map which contains updated Account/Group List and connectorStateMap">
        <Description>Update information Map which contains parsed list of accounts/groups and connectorStateMap</Description>
      </Argument>
    </Returns>
  </Signature>
  <Source><![CDATA[	import java.util.*;
  import java.util.HashMap;
  import java.util.List;
  import java.util.Map;
  import java.util.Map.Entry;
  import java.util.Iterator;
          	import sailpoint.tools.RFC4180LineIterator;
			import sailpoint.tools.RFC4180LineParser;
			   	import java.io.BufferedReader;
			import java.io.ByteArrayInputStream;
			import java.io.IOException;
			import java.io.InputStream;
			import java.io.InputStreamReader;


System.out.println("ELE-Blackline-After-Operation-Rule START: ");
System.out.println("rawResponseObject: "+rawResponseObject);
System.out.println("processedResponseObject: "+processedResponseObject);
//Null check and emptying processedResponseObject.
		
			processedResponseObject.clear();
		
		Map allUserMap = new HashMap();
		
System.out.println("After Clear processedResponseObject: "+processedResponseObject);
  Map updatedMapInfo = new HashMap();


				// convert String into InputStream
				InputStream is = new ByteArrayInputStream(rawResponseObject.getBytes());
				
				
				// read it with BufferedReader
				BufferedReader br = new BufferedReader(new InputStreamReader(is));
				System.out.println("br: "+br);
				
				RFC4180LineIterator lines = new RFC4180LineIterator(br);
				System.out.println("lines: "+lines);
				RFC4180LineParser parser = new RFC4180LineParser(",");
	
				boolean done = false;
				int linesRead = 0;
				String line = null;
				
				System.out.println("loop until done: ");
				// loop until done
				while (!done) {
					
					line = lines.readLine();
					System.out.println("line : "+line);
					// If the current line is null or if the line starts with a # (comment) or size
					// of 0, then continue to the next line.
					if (line == null) {
						done = true;
						continue;
					} else if (line.startsWith("?") ) {
						continue;
					} else {
						linesRead++;
					}
		
					// get a list of tokens for this line
					List tokens = parser.parseLine(line);
					System.out.println("username : "+tokens.get(0));
					String username = tokens.get(0);
					String role = tokens.get(1);
					String userstatus = tokens.get(3);
					String locked = tokens.get(10);
					String entity = tokens.get(12);
					String emailAddress = tokens.get(20);
					emailAddress=emailAddress.toLowerCase();
					HashMap userMap = allUserMap.get(emailAddress);
					if(userMap == null) userMap = new HashMap();
					
					List roles = userMap.get("role");
					if(roles==null) roles= new ArrayList();
					roles.add(role);
					userMap.put("role",roles);
					userMap.put("userstatus",userstatus);
					userMap.put("locked",locked);
					userMap.put("entity",entity);
					userMap.put("emailAddress",emailAddress);
					allUserMap.put(emailAddress,userMap);
				
					
				}
				Iterator it = allUserMap.entrySet().iterator();
			    while (it.hasNext()) {
			        Map.Entry pair = (Map.Entry)it.next();
			        System.out.println(pair.getKey() + " = " + pair.getValue());
			        HashMap userMap = (HashMap)pair.getValue();
			        processedResponseObject.add(userMap);
			        
			    }	
					
				updatedMapInfo.put("data", processedResponseObject);

  return updatedMapInfo;
]]></Source>
</Rule>
